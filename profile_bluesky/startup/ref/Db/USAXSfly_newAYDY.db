# USAXSFly.db - trajectory scan for USAXS fly, to coordinate trajectories for
# AR, AY, and DY motors.
# converted from USAXfly_newAY.db - tmm 6/10/2016
#
# motor					trajectory
# AR $(P)aero:c0:m1		$(P)traj1:M1Traj
# AY $(P)aero:c1:m1		$(P)traj3:M1Traj
# DY $(P)aero:c2:m1		$(P)traj2:M1Traj
#
# Assume the AR array has been written to $(P)traj1:M1Traj, and the
# number of trajectory elements has been written to $(P)traj1:Nelements.
#
# PVs for the number of trajectory points and the total trajectory time are from
# a separate database (USAXSterms.db).
#
#	$(P)USAXS:FS_NumberOfPoints
#	$(P)USAXS:FS_ScanTime

### speed calculations and plotting
# find distance between pairs of adjacent trajectory points
# divide by scan time per point
# find max
record(acalcout, "$(P)$(Q)arCalcSpeed") {
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INAA, "$(P)traj1:M1Traj CP")
	field(INPA, "$(P)USAXS:FS_ScanTime")
	field(INPB, "$(P)USAXS:FS_NumberOfPoints")
	field(CALC, "bb:=((((aa<<1)-aa)>>1)[0,b])/(a/b);c:=amax(abs(bb));bb")
	field(FLNK, "$(P)$(Q)arMaxSpeed")
}
record(ao, "$(P)$(Q)arMaxSpeed") {
	field(PREC, "5")
	field(OMSL, "closed_loop")
	field(DOL, "$(P)$(Q)arCalcSpeed.C")
}

record(acalcout, "$(P)$(Q)ayCalcSpeed") {
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INAA, "$(P)traj3:M1Traj CP")
	field(INPA, "$(P)USAXS:FS_ScanTime")
	field(INPB, "$(P)USAXS:FS_NumberOfPoints")
	field(CALC, "bb:=((((aa<<1)-aa)>>1)[0,b])/(a/b);c:=amax(abs(bb));bb")
	field(FLNK, "$(P)$(Q)ayMaxSpeed")
}
record(ao, "$(P)$(Q)ayMaxSpeed") {
	field(PREC, "5")
	field(OMSL, "closed_loop")
	field(DOL, "$(P)$(Q)ayCalcSpeed.C")
}

record(acalcout, "$(P)$(Q)dyCalcSpeed") {
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INAA, "$(P)traj2:M1Traj CP")
	field(INPA, "$(P)USAXS:FS_ScanTime CP")
	field(INPB, "$(P)USAXS:FS_NumberOfPoints CP")
	field(CALC, "bb:=((((aa<<1)-aa)>>1)[0,b])/(a/b);c:=amax(abs(bb));bb")
	field(FLNK, "$(P)$(Q)dyMaxSpeed")
}
record(ao, "$(P)$(Q)dyMaxSpeed") {
	field(PREC, "5")
	field(OMSL, "closed_loop")
	field(DOL, "$(P)$(Q)dyCalcSpeed.C")
}

record(acalcout, "$(P)$(Q)ARplotXAxis") {
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INPA, "$(P)USAXS:FS_ScanTime CP")
	field(INPB, "$(P)USAXS:FS_NumberOfPoints CP")
	field(CALC, "ix*a/(b-1)")
}
record(acalcout, "$(P)$(Q)AYplotXAxis") {
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INPA, "$(P)USAXS:FS_ScanTime CP")
	field(INPB, "$(P)USAXS:FS_NumberOfPoints CP")
	field(CALC, "ix*a/(b-1)")
}
record(acalcout, "$(P)$(Q)DYplotXAxis") {
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INPA, "$(P)USAXS:FS_ScanTime CP")
	field(INPB, "$(P)USAXS:FS_NumberOfPoints CP")
	field(CALC, "ix*a/(b-1)")
}

# calc AY, DY from AR

# AY---------------------------------
record(acalcout, "$(P)$(Q)calcAYTraj") {
	field(DESC, "calc AY from AR, AY0, SAD, ARcenter")
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INPA, "$(P)USAXS:AY0 CP")
	field(INPC, "$(P)USAXS:SAD CP")
	field(INPD, "$(P)USAXS:ARcenter CP")
	field(INBB, "$(P)traj1:M1Traj CP")
	field(CALC, "aa:=a+c*tan((bb-d)*D2R);aa")
	field(OUT, "$(P)traj3:M1Traj PP")
}

# DY---------------------------------
record(acalcout, "$(P)$(Q)calcDYTraj") {
	field(DESC, "calc DY from AR, DY0, SDD, ARcenter")
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INPA, "$(P)USAXS:DY0 CP")
	field(INPC, "$(P)USAXS:SDD CP")
	field(INPD, "$(P)USAXS:ARcenter CP")
	field(INBB, "$(P)traj1:M1Traj CP")
	field(CALC, "aa:=a+c*tan((bb-d)*D2R);aa")
	field(OUT, "$(P)traj2:M1Traj PP")
}

# fan scan time and number of points where needed
record(transform, "$(P)$(Q)fanScanTime") {
	field(PREC, "3")
	field(INPA, "$(P)USAXS:FS_ScanTime CP")
	# AR
	field(OUTA, "$(P)traj1:Time PP")
	# DY
	field(CLCD, "a")
	field(OUTD, "$(P)traj2:Time PP")
	# AY
	field(CLCE, "a")
	field(OUTE, "$(P)traj3:Time PP")
}
record(transform, "$(P)$(Q)fanNumPoints") {
	field(INPA, "$(P)USAXS:FS_NumberOfPoints CP")
	# AR
	field(OUTA, "$(P)traj1:Nelements PP")
	# DY
	field(CLCC, "a")
	field(OUTC, "$(P)traj2:Nelements PP")
	# AY
	field(CLCD, "a")
	field(OUTD, "$(P)traj3:Nelements PP")
}

# reverse trajectories
record(sseq, "$(P)$(Q)reverseTrajectories") {
	field(DESC, "do trajectory scan")
	field(SDIS, "$(P)$(Q)Start")
	field(DISV, "1")
	field(PREC, "5")

	field(LNK1, "$(P)$(Q)reverseArTraj.PROC CA")
	field(WAIT1, "After3")

	field(LNK2, "$(P)$(Q)reverseAyTraj.PROC CA")
	field(WAIT2, "After3")

	field(LNK3, "$(P)$(Q)reverseDyTraj.PROC CA")
	field(WAIT3, "After3")
}

record(acalcout, "$(P)$(Q)reverseArTraj") {
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INPB, "$(P)traj1:Nelements")
	field(INAA, "$(P)traj1:M1Traj")
	field(CALC, "a:=1;bb:=0;l:=until(bb:=bb+((aa[b-a,b-a])>>(a-1));a:=a+1;a>b);bb")
	field(OUT, "$(P)traj1:M1Traj PP")
}

record(acalcout, "$(P)$(Q)reverseAyTraj") {
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INPB, "$(P)traj3:Nelements")
	field(INAA, "$(P)traj3:M1Traj")
	field(CALC, "a:=1;bb:=0;l:=until(bb:=bb+((aa[b-a,b-a])>>(a-1));a:=a+1;a>b);bb")
	field(OUT, "$(P)traj3:M1Traj PP")
}

record(acalcout, "$(P)$(Q)reverseDyTraj") {
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INPB, "$(P)traj2:Nelements")
	field(INAA, "$(P)traj2:M1Traj")
	field(CALC, "a:=1;bb:=0;l:=until(bb:=bb+((aa[b-a,b-a])>>(a-1));a:=a+1;a>b);bb")
	field(OUT, "$(P)traj2:M1Traj PP")
}


# trajectory execution
record(busy, "$(P)$(Q)Start") {
	field(OUT, "$(P)$(Q)scanSseq PP")
}

record(sseq, "$(P)$(Q)startTrajectories") {
	field(DESC, "start AR, AY, and DY trajectories")
	field(SDIS, "$(P)$(Q)Start")
	field(DISV, "0")
	field(PREC, "5")

	# execute DY trajectory
	field(STR6, "Busy")
	field(LNK6, "$(P)traj2:Execute CA")
	field(WAIT6, "After8")

	# execute AY trajectory
	field(STR7, "Busy")
	field(LNK7, "$(P)traj3:Execute CA")
	field(WAIT7, "After8")

	# execute AR atrajectory
	field(STR8, "Busy")
	field(LNK8, "$(P)traj1:Execute CA")
	field(WAIT8, "Wait")

}

record(sseq, "$(P)$(Q)scanSseq") {
	field(DESC, "do trajectory scan")
	field(SDIS, "$(P)$(Q)Start")
	field(DISV, "0")
	field(PREC, "5")

	# build trajectories
	field(LNK1, "$(P)$(Q)buildTraj.PROC CA")
	field(WAIT1, "Wait")

	# move AR, AY, and DY to start positions (first elements of trajectory),
	# and wait for them to get there.
	field(DOL2, "$(P)traj1:M1Traj")
	field(LNK2, "$(P)$(AR) CA")
	field(WAIT2, "After4")

	field(DOL3, "$(P)traj3:M1Traj")
	field(LNK3, "$(P)$(AY) CA")
	field(WAIT3, "After4")

	field(DOL4, "$(P)traj2:M1Traj")
	field(LNK4, "$(P)$(DY) CA")
	field(WAIT4, "Wait")

	# start MCS
	field(STR5, "Erase")
	field(LNK5, "$(P)3820:EraseStart PP")

	# reset amp-gain recorder
	field(LNK6, "$(P)$(Q)resetGainRecs.PROC PP")

	# execute trajectories, and wait for them to finish
	field(LNK7, "$(P)$(Q)startTrajectories.PROC CA")
	field(WAIT7, "Wait")

	# stop MCS
	field(STR9, "Stop")
	field(LNK9, "$(P)3820:StopAll CA")

	# tell client we're done
	field(STRA, "Done")
	field(LNKA, "$(P)$(Q)Start CA")
	
	# eval AR
	field(FLNK, "$(P)$(Q)evalAR.PROC")
}

record(sseq, "$(P)$(Q)buildTraj") {
	field(SDIS, "$(P)$(Q)Start")
	field(DISV, "0")
	field(PREC, "5")

	# calc Npulses and write to trajectory database and MCS
	field(LNK1, "$(P)$(Q)calcNpulses.PROC CA")
	field(WAIT1, "Wait")

	# build trajectory
	field(STR2, "Busy")
	field(LNK2, "$(P)traj1:Build CA")
	field(WAIT2, "After4")

	# build trajectory
	field(STR3, "Busy")
	field(LNK3, "$(P)traj2:Build CA")
	field(WAIT3, "After4")

	# build trajectory
	field(STR4, "Busy")
	field(LNK4, "$(P)traj3:Build CA")
	field(WAIT4, "Wait")
}

# abort
record(bo, "$(P)$(Q)Abort") {
	field(ZNAM, "Done")
	field(ONAM, "Abort")
	field(OUT, "$(P)$(Q)fanAbort.PROC PP")
}
# abort scan
record(sseq, "$(P)$(Q)fanAbort") {
	# abort scanSseq
	field(DO1, "1")
	field(LNK1, "$(P)$(Q)scanSseq.ABORT PP")
	# Abort trajectories, in case scanSseq has already started them
	field(STR4, "Abort")
	field(LNK4, "$(P)traj1:Abort PP")
	field(STR5, "Abort")
	field(LNK5, "$(P)traj2:Abort PP")
	field(STR6, "Abort")
	field(LNK6, "$(P)traj3:Abort PP")
	# clear busy record, so client knows we're done
	field(STR9, "Done")
	field(LNK9, "$(P)$(Q)Start CA")
}

# Move AY, DY to positions commensurate with AR, via calcout records.
# We shouldn't need this anymore, but it may be useful as a backup.
record(seq, "$(P)$(Q)slave_AY_DY") {
	field(SDIS, "$(P)traj1:Execute")
	field(DISV, "0")
	field(SCAN, "Passive")
	field(LNK1, "$(P)$(Q)slaveAY.PROC PP")
	field(LNK2, "$(P)$(Q)slaveDY.PROC PP")
}
record(calcout, "$(P)$(Q)slaveAY") {
	field(DESC, "move AY to AY(AR)")
	field(INPA, "$(P)USAXS:AY0")
	field(INPB, "$(P)$(AR).RBV")
	field(INPC, "$(P)USAXS:SAD")
	field(INPD, "$(P)USAXS:ARcenter")
	field(CALC, "a+c*tan((b-d)*D2R)")
	field(OUT, "$(P)$(AY) PP")
}
record(calcout, "$(P)$(Q)slaveDY") {
	field(DESC, "move DY to DY(AR)")
	field(INPA, "$(P)USAXS:DY0")
	field(INPB, "$(P)$(AR).RBV")
	field(INPC, "$(P)USAXS:SDD")
	field(INPD, "$(P)USAXS:ARcenter")
	field(CALC, "a+c*tan((b-d)*D2R)")
	field(OUT, "$(P)$(DY) PP")
}

##########################################################################
# calculate Npulses, the number of PSO triggers to be generated during the
# trajectory.  The number of pulses depends on the setting of the Ensemble
# trajectory's user-selected PulseMode (0:Fixed, 1:Array, 2:Traj, 3:None).
record(calcout, "$(P)$(Q)PulseModePlus1") {
	field(DESC, "use input value as seq selector")
	field(INPA, "$(P)traj1:PulseMode")
	field(CALC, "A+1")
}
record(seq, "$(P)$(Q)calcNpulses") {
	field(SELM, "Specified")
	field(SELL, "$(P)$(Q)PulseModePlus1 PP")
	field(LNK1, "$(P)$(Q)calcNpulsesF PP")
	field(LNK2, "$(P)$(Q)calcNpulsesA PP")
	field(LNK3, "$(P)$(Q)calcNpulsesT PP")
}
# fixed-interval pulses; the smallest data-acquisition interval is MinStep;
# the number of pulses, then, is trajectory_length/MinStep.
# Write Npulses to the trajectory and to the MCS.
record(acalcout, "$(P)$(Q)calcNpulsesF") {
	field(DESC, "set npulses for AR trajectory")
	field(NELM, "300")
	field(NUSE, "300")
	field(INPA, "$(P)traj1:Nelements")
	field(INPB, "$(P)USAXS:MinStep")
	field(INPE, "$(P)3820:MaxChannels")
	field(INAA, "$(P)traj1:M1Traj")
	field(CALC, "c:=aa[0,0];d:=aa[a-1,a-1];min(e,(c-d)/b)")
	field(OUT, "$(P)traj1:Npulses PP")
	field(FLNK, "$(P)$(Q)writeMCS_NuseAll")
}
# pulses at trajectory points: the number of pulses is just the number of
# trajectory points.
# Write Npulses to the trajectory and to the MCS.
record(calcout, "$(P)$(Q)calcNpulsesT") {
	field(DESC, "set npulses for AR trajectory")
	field(INPA, "$(P)traj1:Nelements")
	field(INPE, "$(P)3820:MaxChannels")
	field(CALC, "min(e,a)")
	field(OUT, "$(P)traj1:Npulses PP")
	field(FLNK, "$(P)$(Q)writeMCS_NuseAll")
}
# pulses at user-specified points: the number of pulses is just the number
# of points the user specified.
# Write Npulses to the trajectory and to the MCS.
record(calcout, "$(P)$(Q)calcNpulsesA") {
	field(DESC, "set npulses for AR trajectory")
	field(INPA, "$(P)traj1:NumPulsePositions")
	field(INPE, "$(P)3820:MaxChannels")
	field(CALC, "min(e,a)")
	field(OUT, "$(P)traj1:Npulses PP")
	field(FLNK, "$(P)$(Q)writeMCS_NuseAll")
}
# Copy number of pulses to MCS.  It's possible for the Ensemble PSO to generate
# more than the desired number of pulses, because of encoder noise, if it's
# operating in PulseMode=="Fixed".  For now, just add 10%.  This means the MCS
# won't stop by itself, so we won't want to wait for it to stop.
record(calcout, "$(P)$(Q)writeMCS_NuseAll") {
	field(DESC, "set MCS to acquire extra pulses")
	field(INPA, "$(P)traj1:Npulses")
	field(INPB, "$(P)3820:MaxChannels")
	field(INPC, "$(P)traj1:PulseMode")
	field(CALC, "d:=(c?1.0:1.1);min(b,NINT(a*d/100)*100)")
	field(OUT, "$(P)3820:NuseAll CA")
}

##############################################################################
# Reset recordGain databases
record(fanout, "$(P)$(Q)resetGainRecs") {
	field(LNK1, "$(P)$(Q)DDPCA300:resetGain.PROC PP")
	field(LNK2, "$(P)$(Q)DLPCA200:resetGain.PROC PP")
	field(LNK3, "$(P)$(Q)I0:resetGain.PROC PP")
	field(LNK4, "$(P)$(Q)I00:resetGain.PROC PP")
	field(LNK5, "$(P)$(Q)AR:resetPos.PROC PP")
}

# evaluate AY and DY trajectories.  This assumes fixed-interval PSO pulses, and relies on stepper
# pulses recorded by the MCS.  If we're using pulses at user-specified AR points, this algorithm
# won't work.
# With AY and DY controlled by an Ensemble, this algorithm also won't work, though we might have
# them send PSO pulses to the MCS, and set Gs to the distances between PSO pulses.  For now, though,
# we punt the AY and DY trajectory evals.
record(acalcout, "$(P)$(Q)evalAY") {
	field(PREC, "5")
	field(NELM, "$(MAXPULSES)")
	field(NUSE, "$(MAXPULSES)")
	field(INPA, "$(P)USAXS:AY0")
	field(INPB, "$(P)USAXS:MinStep")
	field(INPC, "$(P)USAXS:SAD")
	field(INPD, "$(P)USAXS:ARcenter")
	field(INPE, "$(P)aero:c0:m1.MRES")
	# AY start position
	field(INPF, "$(P)traj3:M1Start")
	# AY PSO distance (not implemented)
	#field(INPG, "$(P)mxv:c1:m1.MRES")
	#field(INPH, "$(P)3820:NuseAll")
	field(INPH, "$(P)traj1:Npulses")
	field(INPI, "$(P)USAXSfly:Start CP")
	field(INAA, "$(P)3820:mca1.VAL")
	field(INBB, "$(P)3820:mca6.VAL")
	field(CALC, "i")
	field(OOPT, "Transition To Zero")
	field(DOPT, "Use OCAL")
	field(OCAL, "cc:=f-cum(bb)*g;dd:=d-ix*(aa>0)*b;ee:=a+c*tan((dd-d)*D2R);(ee-cc)[0,h-1]")
}
record(acalcout, "$(P)$(Q)evalDY") {
	field(PREC, "5")
	field(NELM, "$(MAXPULSES)")
	field(NUSE, "$(MAXPULSES)")
	field(INPA, "$(P)USAXS:DY0")
	field(INPB, "$(P)USAXS:MinStep")
	field(INPC, "$(P)USAXS:SDD")
	field(INPD, "$(P)USAXS:ARcenter")
	field(INPE, "$(P)aero:c0:m1.MRES")
	field(INPF, "$(P)traj2:M2Start")
	field(INPG, "$(P)mxv:c1:m2.MRES")
	#field(INPH, "$(P)3820:NuseAll")
	field(INPH, "$(P)traj1:Npulses")
	field(INPI, "$(P)USAXSfly:Start CP")
	field(INAA, "$(P)3820:mca1.VAL")
	field(INBB, "$(P)3820:mca7.VAL")
	field(CALC, "i")
	field(OOPT, "Transition To Zero")
	field(DOPT, "Use OCAL")
	field(OCAL, "cc:=f-cum(bb)*g;dd:=d-ix*(aa>0)*b;ee:=a+c*tan((dd-d)*D2R);(ee-cc)[0,h-1]")
}

record(acalcout, "$(P)$(Q)acalc1") {
	field(PREC, "5")
	field(NELM, "$(MAXPULSES)")
	field(NUSE, "$(MAXPULSES)")
}
record(acalcout, "$(P)$(Q)acalc2") {
	field(PREC, "5")
	field(NELM, "$(MAXPULSES)")
	field(NUSE, "$(MAXPULSES)")
}
record(acalcout, "$(P)$(Q)acalc3") {
	field(PREC, "5")
	field(NELM, "$(MAXPULSES)")
	field(NUSE, "$(MAXPULSES)")
}
record(acalcout, "$(P)$(Q)acalc4") {
	field(PREC, "5")
	field(NELM, "$(MAXPULSES)")
	field(NUSE, "$(MAXPULSES)")
}
record(acalcout, "$(P)$(Q)acalc5") {
	field(PREC, "5")
	field(NELM, "$(MAXPULSES)")
	field(NUSE, "$(MAXPULSES)")
}
