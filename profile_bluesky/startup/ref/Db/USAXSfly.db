# USAXSFly.db - trajectory scan for USAXS fly, to coordinate trajectories for
# AR, AY, and DY motors.
# tmm 1/21/2014
#
# AR $(P)aero:c0:m1
# AY $(P)mxv:c1:m1
# DY $(P)mxv:c1:m2
#
# Assume the AR array has been written to $(P)traj1:M1Traj, and the
# number of trajectory elements has been written to $(P)traj1:Nelements.
#
# PVs for the number of trajectory points and the total trajectory time are from
# a separate database (USAXSterms.db).
#
#	$(P)USAXS:FS_NumberOfPoints
#	$(P)USAXS:FS_ScanTime

### trajectory pre-execution calculations

# The number of the AR-trajectory point at which the AY and DY trajectories
# are to start.
record(longout, "$(P)$(Q)AYDYstart") {
	field(DESC, "AR point AY and DY start")
	field(DOL, "0")
}

# speed calculations and plotting
record(acalcout, "$(P)$(Q)arCalcSpeed") {
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INAA, "$(P)traj1:M1Traj CP")
	field(INPA, "$(P)USAXS:FS_ScanTime")
	field(INPB, "$(P)USAXS:FS_NumberOfPoints")
	field(CALC, "bb:=(((aa<<1)-aa)>>1)[0,b];c:=amax(abs(bb));bb")
	field(FLNK, "$(P)$(Q)arMaxSpeed")
}
record(ao, "$(P)$(Q)arMaxSpeed") {
	field(PREC, "5")
	field(OMSL, "closed_loop")
	field(DOL, "$(P)$(Q)arCalcSpeed.C")
}

record(acalcout, "$(P)$(Q)ayCalcSpeed") {
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INAA, "$(P)traj2:M1Traj CP")
	field(INPA, "$(P)USAXS:FS_ScanTime")
	field(INPB, "$(P)USAXS:FS_NumberOfPoints")
	field(INPD, "$(P)$(Q)AYDYstart CP")
	field(CALC, "bb:=(((aa<<1)-aa)>>1)[0,b-d-1];c:=amax(abs(bb));bb[0,b-d-2]")
	field(FLNK, "$(P)$(Q)ayMaxSpeed")
}
record(ao, "$(P)$(Q)ayMaxSpeed") {
	field(PREC, "5")
	field(OMSL, "closed_loop")
	field(DOL, "$(P)$(Q)ayCalcSpeed.C")
}

record(acalcout, "$(P)$(Q)dyCalcSpeed") {
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INAA, "$(P)traj2:M2Traj CP")
	field(INPA, "$(P)USAXS:FS_ScanTime CP")
	field(INPB, "$(P)USAXS:FS_NumberOfPoints CP")
	field(INPD, "$(P)$(Q)AYDYstart CP")
	field(CALC, "bb:=(((aa<<1)-aa)>>1)[0,b-d-1];c:=amax(abs(bb));bb[0,b-d-2]")
	#field(CALC, "bb:=(((aa<<1)-aa)>>1)[0,b];c:=amax(abs(bb));bb<<d")
	field(FLNK, "$(P)$(Q)dyMaxSpeed")
}
record(ao, "$(P)$(Q)dyMaxSpeed") {
	field(PREC, "5")
	field(OMSL, "closed_loop")
	field(DOL, "$(P)$(Q)dyCalcSpeed.C")
}

record(acalcout, "$(P)$(Q)ARplotXAxis") {
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INPA, "$(P)USAXS:FS_ScanTime CP")
	field(INPB, "$(P)USAXS:FS_NumberOfPoints CP")
	field(CALC, "ix*a/(b-1)")
}
record(acalcout, "$(P)$(Q)AYDYplotXAxis") {
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INPA, "$(P)USAXS:FS_ScanTime CP")
	field(INPB, "$(P)USAXS:FS_NumberOfPoints CP")
	field(INPC, "$(P)$(Q)AYDYstart CP")
	field(CALC, "(ix*a/(b-1))[0,b-c]")
}

# calc AY, DY from AR
# Also, start AY and DY trajectories only after AR trajectory is fast enough that the
# MAXv can do a good job of keeping time.

# For plotting Ay/Dy trajectories, calc num points
record(calcout, "$(P)$(Q)AYDYNumPoints") {
	field(INPA, "$(P)USAXS:FS_NumberOfPoints CP")
	field(INPB, "$(P)$(Q)AYDYstart CP")
	field(CALC, "a-b")
}

# AY---------------------------------
record(acalcout, "$(P)$(Q)calcAYTraj") {
	field(DESC, "calc AY from AR, AY0, SAD, ARcenter")
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INPA, "$(P)USAXS:AY0 CP")
	field(INPC, "$(P)USAXS:SAD CP")
	field(INPD, "$(P)USAXS:ARcenter CP")
	field(INPE, "$(P)$(Q)AYDYstart CP")
	field(INBB, "$(P)traj1:M1Traj CP")
	#field(CALC, "aa:=a+c*tan((bb-d)*D2R);aa<<e")
	# First point is where AY would start if it weren't starting late.
	# This isn't exactly right, because the MAXv trajectory software will
	# add a starting point that accounts for the acceleration time
	# and the average speed over the first trajectory segment.
	#
	# This expression puts a transient in AR motion when AY starts
	# tmm 2/20/2014
	#field(CALC, "aa:=a+c*tan((bb-d)*D2R);f:=aa;(aa<<e){1,-1}+f[0,0]")
	field(CALC, "aa:=a+c*tan((bb-d)*D2R);f:=aa;(aa<<e)")
	field(OUT, "$(P)traj2:M1Traj PP")
}
record(ao, "$(P)$(Q)AYTolerance") {
	field(PREC, "3")
	field(DOL, ".05")
}

# DY---------------------------------
record(acalcout, "$(P)$(Q)calcDYTraj") {
	field(DESC, "calc DY from AR, DY0, SDD, ARcenter")
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INPA, "$(P)USAXS:DY0 CP")
	field(INPC, "$(P)USAXS:SDD CP")
	field(INPD, "$(P)USAXS:ARcenter CP")
	field(INPE, "$(P)$(Q)AYDYstart CP")
	field(INBB, "$(P)traj1:M1Traj CP")
	#field(CALC, "aa:=a+c*tan((bb-d)*D2R);aa<<e")
	# start halfway between ideal start point and user-specified start point
	field(CALC, "aa:=a+c*tan((bb-d)*D2R);f:=aa;g:=aa[e,e];(aa<<e){1,-1}+((f+g)/2)[0,0]")
	field(OUT, "$(P)traj2:M2Traj PP")
}
record(ao, "$(P)$(Q)DYTolerance") {
	field(PREC, "3")
	field(DOL, ".1")
}

# fan scan time and number of points where needed
record(transform, "$(P)$(Q)fanScanTime") {
	field(PREC, "3")
	field(INPA, "$(P)USAXS:FS_ScanTime CP")
	field(INPB, "$(P)$(Q)AYDYstart CP")
	field(INPC, "$(P)USAXS:FS_NumberOfPoints CP")
	field(OUTA, "$(P)traj1:Time PP")
	field(CLCD, "a*(c-b)/c")
	field(OUTD, "$(P)traj2:Time PP")
}
record(transform, "$(P)$(Q)fanNumPoints") {
	field(INPA, "$(P)USAXS:FS_NumberOfPoints CP")
	field(INPB, "$(P)$(Q)AYDYstart CP")
	field(OUTA, "$(P)traj1:Nelements PP")
	field(CLCC, "a-b")
	field(OUTC, "$(P)traj2:Nelements PP")
}

# reverse trajectories
record(sseq, "$(P)$(Q)reverseTrajectories") {
	field(DESC, "do trajectory scan")
	field(SDIS, "$(P)$(Q)Start")
	field(DISV, "1")
	field(PREC, "5")

	field(LNK1, "$(P)$(Q)reverseArTraj.PROC CA")
	field(WAIT1, "After3")

	field(LNK2, "$(P)$(Q)reverseAyTraj.PROC CA")
	field(WAIT2, "After3")

	field(LNK3, "$(P)$(Q)reverseDyTraj.PROC CA")
	field(WAIT3, "After3")
}

record(acalcout, "$(P)$(Q)reverseArTraj") {
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INPB, "$(P)traj1:Nelements")
	field(INAA, "$(P)traj1:M1Traj")
	field(CALC, "a:=1;bb:=0;l:=until(bb:=bb+((aa[b-a,b-a])>>(a-1));a:=a+1;a>b);bb")
	field(OUT, "$(P)traj1:M1Traj PP")
}

record(acalcout, "$(P)$(Q)reverseAyTraj") {
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INPB, "$(P)traj2:Nelements")
	field(INAA, "$(P)traj2:M1Traj")
	field(CALC, "a:=1;bb:=0;l:=until(bb:=bb+((aa[b-a,b-a])>>(a-1));a:=a+1;a>b);bb")
	field(OUT, "$(P)traj2:M1Traj PP")
}

record(acalcout, "$(P)$(Q)reverseDyTraj") {
	field(PREC, "5")
	field(NELM, "$(MAXPTS)")
	field(NUSE, "$(MAXPTS)")
	field(INPB, "$(P)traj2:Nelements")
	field(INAA, "$(P)traj2:M2Traj")
	field(CALC, "a:=1;bb:=0;l:=until(bb:=bb+((aa[b-a,b-a])>>(a-1));a:=a+1;a>b);bb")
	field(OUT, "$(P)traj2:M2Traj PP")
}


# trajectory execution
record(busy, "$(P)$(Q)Start") {
	field(OUT, "$(P)$(Q)scanSseq PP")
}
record(calcout, "$(P)$(Q)AYDYtrigger") {
	field(PREC, "5")
	field(INPA, "$(P)3820:CurrentChannel CP")
	field(INPB, "$(P)traj1:ExecState NPP")
	field(CALC, "(a>c)&&(b==2)")
	field(OUT, "9idcUSX:ath01:reg01:bo08 CA")
}

record(sseq, "$(P)$(Q)scanSseq") {
	field(DESC, "do trajectory scan")
	field(SDIS, "$(P)$(Q)Start")
	field(DISV, "0")
	field(PREC, "5")

	# build trajectories
	field(LNK1, "$(P)$(Q)buildTraj.PROC CA")
	field(WAIT1, "Wait")

	# move AR, AY, and DY to start positions (first elements of trajectory),
	# and wait for them to get there.
	field(DOL2, "$(P)traj1:M1Traj")
	field(LNK2, "$(P)$(AR) CA")
	field(WAIT2, "After4")

	field(DOL3, "$(P)traj2:M1Traj")
	field(LNK3, "$(P)$(AY) CA")
	field(WAIT3, "After4")

	field(DOL4, "$(P)traj2:M2Traj")
	field(LNK4, "$(P)$(DY) CA")
	field(WAIT4, "Wait")

	# start MCS
	field(STR5, "Erase")
	field(LNK5, "$(P)3820:EraseStart PP")

	# reset amp-gain recorder
	field(LNK6, "$(P)$(Q)resetGainRecs.PROC PP")

	# execute AY and DY trajectories
	field(STR7, "Busy")
	field(LNK7, "$(P)traj2:Execute CA")
	field(WAIT7, "After8")

	# execute AR trajectory after delay intended to sync with AY, DY
	field(DLY8, "0.2")
	field(STR8, "Busy")
	field(LNK8, "$(P)traj1:Execute CA")
	field(WAIT8, "Wait")

	# stop MCS
	field(STR9, "Stop")
	field(LNK9, "$(P)3820:StopAll CA")

	# tell client we're done
	field(STRA, "Done")
	field(LNKA, "$(P)$(Q)Start CA")
	
	# eval AR
	field(FLNK, "$(P)$(Q)evalAR.PROC")
}

record(sseq, "$(P)$(Q)buildTraj") {
	field(SDIS, "$(P)$(Q)Start")
	field(DISV, "0")
	field(PREC, "5")

	# calc Npulses and write to trajectory database and MCS
	field(LNK1, "$(P)$(Q)calcNpulses.PROC CA")
	field(WAIT1, "Wait")

	# build trajectory
	field(STR2, "Busy")
	field(LNK2, "$(P)traj1:Build CA")
	field(WAIT2, "After3")

	# build trajectory
	field(STR3, "Busy")
	field(LNK3, "$(P)traj2:Build CA")
	field(WAIT3, "Wait")
}

# abort
record(bo, "$(P)$(Q)Abort") {
	field(ZNAM, "Done")
	field(ONAM, "Abort")
	field(OUT, "$(P)$(Q)fanAbort.PROC PP")
}
# fan abort to trajectories
record(sseq, "$(P)$(Q)fanAbort") {
	field(DO1, "1")
	field(LNK1, "$(P)$(Q)scanSseq.ABORT PP")
	field(DO2, "1")
	field(LNK2, "$(P)$(Q)AYDYtrigger.D PP")
	field(DO3, "0")
	field(LNK3, "$(P)$(Q)AYDYtrigger.D PP")
	field(STR4, "Abort")
	field(LNK4, "$(P)traj2:Abort PP")
	field(STR5, "Abort")
	field(LNK5, "$(P)traj1:Abort PP")
	field(DO6, "1")
	field(LNK6, "$(P)$(Q)scanSseq.ABORT PP")
	field(DLY7, "1")
	field(STR7, "Abort")
	field(LNK7, "$(P)traj1:Abort PP")
	field(DLY8, "1")
	field(STR8, "Abort")
	field(LNK8, "$(P)traj1:Abort PP")
	field(STR9, "Done")
	field(LNK9, "$(P)$(Q)Start CA")
}

# Slave AY, DY to AR via calcout records.  We shouldn't need this anymore, but
# it may be useful for the scan region in which AY and DY must move too slowly
# for their trajectories to keep good time.
record(seq, "$(P)$(Q)slave_AY_DY") {
	field(SDIS, "$(P)traj1:Execute")
	field(DISV, "0")
	field(SCAN, "Passive")
	field(LNK1, "$(P)$(Q)slaveAY.PROC PP")
	field(LNK2, "$(P)$(Q)slaveDY.PROC PP")
}
record(calcout, "$(P)$(Q)slaveAY") {
	field(DESC, "move AY to AY(AR)")
	field(INPA, "$(P)USAXS:AY0")
	field(INPB, "$(P)$(AR).RBV")
	field(INPC, "$(P)USAXS:SAD")
	field(INPD, "$(P)USAXS:ARcenter")
	field(CALC, "a+c*tan((b-d)*D2R)")
	field(OUT, "$(P)$(AY) PP")
}
record(calcout, "$(P)$(Q)slaveDY") {
	field(DESC, "move DY to DY(AR)")
	field(INPA, "$(P)USAXS:DY0")
	field(INPB, "$(P)$(AR).RBV")
	field(INPC, "$(P)USAXS:SDD")
	field(INPD, "$(P)USAXS:ARcenter")
	field(CALC, "a+c*tan((b-d)*D2R)")
	field(OUT, "$(P)$(DY) PP")
}

##########################################################################
# calculate Npulses, the number of PSO triggers to be generated during the
# trajectory.  The number of pulses depends on the setting of the Ensemble
# trajectory's user-selected PulseMode (0:Fixed, 1:Array, 2:Traj, 3:None).
record(calcout, "$(P)$(Q)PulseModePlus1") {
	field(DESC, "use input value as seq selector")
	field(INPA, "$(P)traj1:PulseMode")
	field(CALC, "A+1")
}
record(seq, "$(P)$(Q)calcNpulses") {
	field(SELM, "Specified")
	field(SELL, "$(P)$(Q)PulseModePlus1 PP")
	field(LNK1, "$(P)$(Q)calcNpulsesF PP")
	field(LNK2, "$(P)$(Q)calcNpulsesA PP")
	field(LNK3, "$(P)$(Q)calcNpulsesT PP")
}
# fixed-interval pulses; the smallest data-acquisition interval is MinStep;
# the number of pulses, then, is trajectory_length/MinStep.
# Write Npulses to the trajectory and to the MCS.
record(acalcout, "$(P)$(Q)calcNpulsesF") {
	field(DESC, "set npulses for AR trajectory")
	field(NELM, "300")
	field(NUSE, "300")
	field(INPA, "$(P)traj1:Nelements")
	field(INPB, "$(P)USAXS:MinStep")
	field(INPE, "$(P)3820:MaxChannels")
	field(INAA, "$(P)traj1:M1Traj")
	field(CALC, "c:=aa[0,0];d:=aa[a-1,a-1];min(e,(c-d)/b)")
	field(OUT, "$(P)traj1:Npulses PP")
	field(FLNK, "$(P)$(Q)writeMCS_NuseAll")
}
# pulses at trajectory points: the number of pulses is just the number of
# trajectory points.
# Write Npulses to the trajectory and to the MCS.
record(calcout, "$(P)$(Q)calcNpulsesT") {
	field(DESC, "set npulses for AR trajectory")
	field(INPA, "$(P)traj1:Nelements")
	field(INPE, "$(P)3820:MaxChannels")
	field(CALC, "min(e,a)")
	field(OUT, "$(P)traj1:Npulses PP")
	field(FLNK, "$(P)$(Q)writeMCS_NuseAll")
}
# fpulses at user-specified points: the number of pulses is just the number
# of points the user specified.
# Write Npulses to the trajectory and to the MCS.
record(calcout, "$(P)$(Q)calcNpulsesA") {
	field(DESC, "set npulses for AR trajectory")
	field(INPA, "$(P)traj1:NumPulsePositions")
	field(INPE, "$(P)3820:MaxChannels")
	field(CALC, "min(e,a)")
	field(OUT, "$(P)traj1:Npulses PP")
	field(FLNK, "$(P)$(Q)writeMCS_NuseAll")
}
# Copy number of pulses to MCS.  It's possible for the Ensemble PSO to generate
# more than the desired number of pulses, because of encoder noise, if it's
# operating in PulseMode=="Fixed".  For now, just add 10%.  This means the MCS
# won't stop by itself, so we won't want to wait for it to stop.
record(calcout, "$(P)$(Q)writeMCS_NuseAll") {
	field(DESC, "set MCS to acquire extra pulses")
	field(INPA, "$(P)traj1:Npulses")
	field(INPB, "$(P)3820:MaxChannels")
	field(INPC, "$(P)traj1:PulseMode")
	field(CALC, "d:=(c?1.0:1.1);min(b,NINT(a*d/100)*100)")
	field(OUT, "$(P)3820:NuseAll CA")
}

##########################################################################
# calculate trigger channel at which AY and DY start moving.  User specifies
# this as the trajectory point; we have to translate that to a number that
# depends on the setting of the Ensemble trajectory's user-selected PulseMode
# (0:Fixed, 1:Array, 2:Traj, 3:None).
record(calcout, "$(P)$(Q)calcAyDyStart") {
	field(DESC, "use input value as seq selector")
	field(INPA, "$(P)traj1:PulseMode CP")
	field(INPB, "$(P)$(Q)AYDYstart CP")
	field(INPC, "$(P)USAXS:MinStep CP")
	field(INPD, "$(P)traj1:M1Traj CP")
	field(INPE, "$(P)traj1:PulsePositions CP")
	field(CALC, "0")
	field(FLNK, "$(P)$(Q)selAyDyStart")
}
record(seq, "$(P)$(Q)selAyDyStart") {
	field(SELM, "Specified")
	field(SELL, "$(P)$(Q)PulseModePlus1 PP")
	field(LNK1, "$(P)$(Q)calcAyDyStartF PP")
	field(LNK2, "$(P)$(Q)calcAyDyStartA PP")
	field(LNK3, "$(P)$(Q)calcAyDyStartT PP")
}
# fixed-interval pulses: the trigger pulse comes after we've moved the distance
# abs(dbl(aa[0,0])-dbl(aa[a,a])).  The number of pulses is the distance/MinStep. 
record(acalcout, "$(P)$(Q)calcAyDyStartF") {
	field(DESC, "calc trigger channel")
	field(PREC, "5")
	field(NELM, "$(MAXPULSES)")
	field(NUSE, "$(MAXPULSES)")
	field(INPA, "$(P)$(Q)AYDYstart")
	field(INPB, "$(P)USAXS:MinStep")
	field(INAA, "$(P)traj1:M1Traj")
	field(CALC, "abs(dbl(aa[0,0])-dbl(aa[a,a]))/b")
	field(OUT, "$(P)$(Q)AYDYtrigger.C NPP")
}
# pulses at trajectory points: the number of pulses is just the user specified
# number
record(calcout, "$(P)$(Q)calcAyDyStartT") {
	field(DESC, "calc trigger channel")
	field(PREC, "5")
	field(INPA, "$(P)$(Q)AYDYstart")
	field(CALC, "a")
	field(OUT, "$(P)$(Q)AYDYtrigger.C NPP")
}
# pulses at user-specified points: find the AR motor position at which AY and DY
# should start, find the index of that position in the user-specified pulse
# array by subtracting the position from all elements of the pulse array, and
# finding the first zero crossing of the result.
record(acalcout, "$(P)$(Q)calcAyDyStartA") {
	field(DESC, "calc trigger channel")
	field(PREC, "5")
	field(NELM, "$(MAXPULSES)")
	field(NUSE, "$(MAXPULSES)")
	field(INPA, "$(P)$(Q)AYDYstart")
	field(INAA, "$(P)traj1:M1Traj")
	field(INBB, "$(P)traj1:PulsePositions")
	field(CALC, "b:=dbl(aa[a,a]);ixz(bb-b)")
	field(OUT, "$(P)$(Q)AYDYtrigger.C NPP")
}

##############################################################################
# Reset recordGain databases
record(fanout, "$(P)$(Q)resetGainRecs") {
	field(LNK1, "$(P)$(Q)DDPCA300:resetGain.PROC PP")
	field(LNK2, "$(P)$(Q)DLPCA200:resetGain.PROC PP")
	field(LNK3, "$(P)$(Q)I0:resetGain.PROC PP")
	field(LNK4, "$(P)$(Q)I00:resetGain.PROC PP")
	field(LNK5, "$(P)$(Q)AR:resetPos.PROC PP")
}

# evaluate trajectories.  This assumes fixed-interval PSO pulses.  If we're using
# pulses at user-specified points, we rely on the controller to be where the PSO says it's at.
record(acalcout, "$(P)$(Q)evalAY") {
	field(PREC, "5")
	field(NELM, "$(MAXPULSES)")
	field(NUSE, "$(MAXPULSES)")
	field(INPA, "$(P)USAXS:AY0")
	field(INPB, "$(P)USAXS:MinStep")
	field(INPC, "$(P)USAXS:SAD")
	field(INPD, "$(P)USAXS:ARcenter")
	field(INPE, "$(P)aero:c0:m1.MRES")
	field(INPF, "$(P)traj2:M1Start")
	field(INPG, "$(P)mxv:c1:m1.MRES")
	#field(INPH, "$(P)3820:NuseAll")
	field(INPH, "$(P)traj1:Npulses")
	field(INPI, "$(P)USAXSfly:Start CP")
	field(INAA, "$(P)3820:mca1.VAL")
	field(INBB, "$(P)3820:mca6.VAL")
	field(CALC, "i")
	field(OOPT, "Transition To Zero")
	field(DOPT, "Use OCAL")
	field(OCAL, "cc:=f-cum(bb)*g;dd:=d-ix*(aa>0)*b;ee:=a+c*tan((dd-d)*D2R);(ee-cc)[0,h-1]")
}
record(acalcout, "$(P)$(Q)evalDY") {
	field(PREC, "5")
	field(NELM, "$(MAXPULSES)")
	field(NUSE, "$(MAXPULSES)")
	field(INPA, "$(P)USAXS:DY0")
	field(INPB, "$(P)USAXS:MinStep")
	field(INPC, "$(P)USAXS:SDD")
	field(INPD, "$(P)USAXS:ARcenter")
	field(INPE, "$(P)aero:c0:m1.MRES")
	field(INPF, "$(P)traj2:M2Start")
	field(INPG, "$(P)mxv:c1:m2.MRES")
	#field(INPH, "$(P)3820:NuseAll")
	field(INPH, "$(P)traj1:Npulses")
	field(INPI, "$(P)USAXSfly:Start CP")
	field(INAA, "$(P)3820:mca1.VAL")
	field(INBB, "$(P)3820:mca7.VAL")
	field(CALC, "i")
	field(OOPT, "Transition To Zero")
	field(DOPT, "Use OCAL")
	field(OCAL, "cc:=f-cum(bb)*g;dd:=d-ix*(aa>0)*b;ee:=a+c*tan((dd-d)*D2R);(ee-cc)[0,h-1]")
}

record(acalcout, "$(P)$(Q)acalc1") {
	field(PREC, "5")
	field(NELM, "$(MAXPULSES)")
	field(NUSE, "$(MAXPULSES)")
}
record(acalcout, "$(P)$(Q)acalc2") {
	field(PREC, "5")
	field(NELM, "$(MAXPULSES)")
	field(NUSE, "$(MAXPULSES)")
}
record(acalcout, "$(P)$(Q)acalc3") {
	field(PREC, "5")
	field(NELM, "$(MAXPULSES)")
	field(NUSE, "$(MAXPULSES)")
}
record(acalcout, "$(P)$(Q)acalc4") {
	field(PREC, "5")
	field(NELM, "$(MAXPULSES)")
	field(NUSE, "$(MAXPULSES)")
}
record(acalcout, "$(P)$(Q)acalc5") {
	field(PREC, "5")
	field(NELM, "$(MAXPULSES)")
	field(NUSE, "$(MAXPULSES)")
}
