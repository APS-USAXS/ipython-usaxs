########################################################################
# Generic macros
# Author: X.Jiao
# Macors: gm -> puts several motors in one group
#         ugm-> ungroups motor from the group or
#               removes the whole group
#         lmg->  lists groups which the motor belongs to
#         lg -> lists all motors in each group 
#         wg->  like wm but only displays the motors in that group
#
#-----------------------------------------------------------------------
#
#$Log: showmotors.mac,v $
#Revision 1.3  2006/05/11 21:28:55  jiaox
#Improved wg so that it can adjust the format based on the tty size. Changed the previous lg to lmg, and added lg to list all motors in each group.
#
#Revision 1.2  2006/05/11 17:26:38  jiaox
#Corrected few typos.
#
#Revision 1.1  2006/05/11 17:24:12  jiaox
#First Version.
#
########################################################################

global  BCDA_GM[]


def gm '{
     local i,j,n,n2, m[],gm,grpn,flag,mi; 
     if($# <2) {
         eprint "Usage: gm grp_name mne [mne ...]"
         eprint "       if grp_name is "0", "null" or "none", mne is ungrouped"
         exit
     }
     n=split("$*",m)
     grpn=m[0];
     
     for(i=1;i<n;i++) {
         if((mi=motor_num(m[i]))<0) {
            printf("invalid motor mnemonic %s\n",m[i]);
            exit
         }
     }     

     if(m[0]== "0" || m[0]=="none" || m[0]=="null") {
        for(i=1;i<n;i++) {
           for( j in BCDA_GM) {
                BCDA_GM[j]=strjoin(BCDA_GM[j],sprintf("%s ",m[i]))
                if ( BCDA_GM[j]== "") delete BCDA_GM[j];                
           }
           
        }
        exit
     }
     flag =0;
     for(i in BCDA_GM) {
         if(i== grpn) {
           flag=1;
           break;
         }
     }
     if(!flag) BCDA_GM[grpn]=""             

     gm=""
     for(i=1;i<n;i++) {
        gm = strjoin(BCDA_GM[grpn],sprintf("%s ",m[i]))
        
        if(gm ==BCDA_GM[grpn]) {
           BCDA_GM[grpn]=sprintf("%s%s ",BCDA_GM[grpn],m[i])
        }
     }
         
    
}'

def ugm '{
    local i,j,n,m[],gm[],foo
    if( $# <1) {
        eprint("Usage: ugm grp_name [mne...]")
        eprint("       if no mne is given, the whole group is removed.")
        eprint("       if grp_name is \"all\", all groups is removed.")
        exit
    }
    if($# ==1 ) {
       if( "$1" == "all") {
         for(i in BCDA_GM) {
            delete BCDA_GM[i]
         }
         p "all motor groups are removed"
         exit
       }
       if(BCDA_GM["$1"]) {
            delete BCDA_GM["$1"]
       }else {
            printf("Group %s does not exist!\n","$1")
       }
       exit
    } 
    n=split("$*",m)
    for( i=1;i<n;i++){
       if (motor_num(m[i])<0) {
         printf("invalid motor mnemonic %s\n",m[i])
         exit
       }
    }  
         
    for(i=1;i<n;i++){
      BCDA_GM[m[0]]=strjoin(BCDA_GM[m[0]],sprintf("%s ",m[i]))
    }  
    if(BCDA_GM[m[0]]=="") delete BCDA_GM[m[0]]
 
}'

def lg '{
    local i g[] n
    if($#==0){
      for(i in BCDA_GM)
          printf("group %s: %s\n",i,BCDA_GM[i])  
      exit
    }
    n=split("$*",g)
    
    for(i=0;i<n;i++) {
       printf("group %s: %s\n",g[i],BCDA_GM[g[i]])
    }    

}'


def lmg ' {
     local m[],n,i,foo,j
     if($# <1) {
         eprint("Usage: lg mne [mne...]")
         exit
     }
     n=split("$*",m)
     for(i in m) {
       if(motor_num(m[i])<0) {
         printf("invalid motor mnemonic %s\n",m[i])
         exit
       } 
     }
     for(i=0;i<n;i++){
        foo="";
        for(j in BCDA_GM) {
           if(strjoin(BCDA_GM[j],sprintf("%s ",m[i])) != BCDA_GM[j])
             foo=sprintf("%s%s ",foo,j);
        }
        printf("%s in group:  %s\n",m[i],foo);
     }
     
}'


def wg '{
    local g[],m[],n,n2,i,j,mi,cols,l1,l2,l3,l4,l5
    if ($#<1) {
        eprint "Usage: sg grp [grp ...]"
        exit
    }
     
    n=split("$*",g)
    for(i in g) {
        if(!BCDA_GM[g[i]]) { 
           printf("invalid motor group name %s ", g[i])
           exit
        }
    }
    tty_cntl("resized?");
    cols=int((COLS-12)/11);
    waitmove
    get_angles
    l2="\nUser"
    for(i=0;i<n;i++) {
           printf("\nmotors in group %s",g[i])
           n2 = split(BCDA_GM[g[i]],m)
           
           for(j=0;j<n2;j++) {
              if((j==0) ||( j%cols==0)) {
                  l1=sprintf("\n%10s", "")
                  l3=sprintf("\n%-10s"," High")
                  l4=sprintf("\n%-10s"," Current")
                  l5=sprintf("\n%-10s"," Low")
              }
              mi=motor_num(m[j]);
              l1=sprintf("%s %10.9s",l1,m[j]);
              l3=sprintf("%s %10.4f",l3,user(mi,get_lim(mi,1)))
              l4=sprintf("%s %10.4f",l4,A[mi]);
              l5=sprintf("%s %10.4f",l5,user(mi,get_lim(mi,-1)));
              if(((j>0)&&((j+1)%cols == 0)) || ((j+1)==n2)){
                  printf("%s%s%s%s%s",l1,l2,l3,l4,l5);
              }
          
           }
           #if((j%(cols+1))!=0){
           #   printf("%s%s%s%s%s",l1,l2,l3,l4,l5)
           #}
           printf("\n")
    }    

}'

















