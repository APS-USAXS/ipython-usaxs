"""
Perform scans of any type of EPICS positioners (motors, analog inputs,
etc.) from SPEC.

Description
===========
These macros allow for the scanning of almost arbitrary EPICS input
channel values directly from SPEC as a standard SPEC scan. The data is
written to the SPEC datafile in the same format as other SPEC scans and
adheres to all formatting conventions, making it readable with any SPEC
file reader.
In contrast to standard SPEC motor scans, the scans in :spec:def:`epics_scan`
require two PV channel names per scanned positioner. The first one specifies
the PV channel used to drive the positioner (called the "drive PV", which holds
the nominal requested input value) and the second one gives the PV channel
to be read after the positioning process has finished (called the "read
PV", which contains the actually achieved value). As an example, for EPICS
motor scans, the drive PV would be the motor record value field (e.g.,
"motor.VAL") and the read PV would be the readback value field (e.g.,
"motor.RBV"). In case of simpler EPICS record types, as for example in an
analog output record, the actual readback value may not be available in
EPICS. In this case, the read PV should be the same as the drive PV,
reading back the nominal drive position. The SPEC data file will always
contain columns for both the drive and read PV values, even if they
originate from the identical PV. The SPEC plot is always built based on
the actual positioner value from the read PV.


Note
====
The functionality of these macros is based on the assumption that the EPICS
channels to be scanned have properly defined callback events. This is
to assure completion of one operation (usually the change in the positioner
value) before initiating the next operation (triggering the counters).
Callback events are implemented consistently throughout the EPICS synApps
package, so those EPICS channels should work well.


Installation
============

Setup
-----
No special configuration is needed to run these macros. Simply load the macro
file::

  > qdo epics_scan.mac

Dependencies
------------
There are no dependencies on other macros.

File information
================

AUTHOR:

  * Christian M. Schlepuetz (CS, cschlep),
    Argonne National Laboratory, cschlep@aps.anl.gov

CREATION DATE:

  2012-02-28

COPYRIGHT:

  .. automatically retrieve the current year:
  .. |current_year| date:: %Y

  Copyright (c) 2010-|current_year|, UChicago Argonne, LLC

  All Rights Reserved

  APS SPEC macros

  APS SPEC development team,
  X-ray Science Division and APS Engineering Support Division,
  Argonne National Laboratory

LICENSE:

  UChicago Argonne, LLC, OPEN SOURCE LICENSE.
  See LICENSE file included with this distribution.

VERSION::

  $Revision: 904 $
  $Date: 2014-03-10 15:43:55 -0500 (Mon, 10 Mar 2014) $
  $Author: jemian $
  $URL: https://subversion.xray.aps.anl.gov/spec/common/aps/epics_scan.mac $

CHANGE LOG:

  2012-02-28 (CS):

  - Created first version

  2014-01-31 (CS):

  - Added :spec:def:`epics_mesh`

TODO:

  - limit checking?
  - arbitrary number of read PVs?
  - a<N>scans, d<N>scans

"""

#==============================================================================
# Global variable definitions
#==============================================================================

  #: Name of the epics_scan macro file [str]
  global EPICS_SCAN_MAC
         EPICS_SCAN_MAC = DOFILE

  #: Default callback timeout in seconds [float]
  global EPICS_SCAN_CALLBACK_TIMEOUT
         EPICS_SCAN_CALLBACK_TIMEOUT = 1000

  #: Associate array with the read PVs for the scan [str]
  global EPICS_SCAN_READ_PVS[]
  #: Associate array with the start positios for all positioners [float]
  global EPICS_SCAN_START_POS[]

  #: Debug flag [int]
  global EPICS_SCAN_DEBUG
         EPICS_SCAN_DEBUG = 0

#==============================================================================
# Macro command definitions
#==============================================================================

#------------------------------------------------------------------------------
def epics_scan_help '{
  """
  Displays the epics_scan help text.

  USAGE::

    > epics_scan_help

  NOTE:
    The help text is generated by simply displaying the text file
    epics_scan_mac.txt, which should reside in the same directory as
    epics_scan.mac. If the file does not exist, a generic help text defined in
    epics_scan_help is shown.

 """

  unix(sprintf("dirname %s", EPICS_SCAN_MAC), _1)
  ll = length (_1)
  if(substr(_1, ll, 1) == "\n") _1 = substr(_1, 1, (ll - 1))
  file = sprintf("%s/epics_scan_mac.txt", _1)
  if(file_info(file, "-e")) {
    unix(sprintf("cat %s", file))
  } else {
    printf("\n  Macros available in file epics_scan.mac ($Revision: 904 $):\n")
    printf(  "                           ===========\n")
    printf("\n")
    printf("  epics_scan_help      - displays this help text\n")
    printf("  epics_ascan          - absolute scan of an EPICS positioner\n")
    printf("  epics_dscan          - relative scan of an EPICS positioner\n")
  }
}'


#------------------------------------------------------------------------------
def epics_ascan '{
  """
  Absolute scan of an EPICS positioner.

  USAGE::

    > epics_ascan <drive_PV> <read_PV> <start> <finish> <intervals> <time>
        [<positioner_settling_time> [<counter_settling_time>]]

  ARGUMENTS:

    Required arguments:

      :drive_PV:   Name of the PV channel to drive the positioner
      :read_PV:    Name of the PV channel to read the positioner value
      :start:      Start position for the scan
      :finish:     End position for the scan
      :intervals:  Number of steps (points = steps+1)
      :time:       Counting time [s]

    Optional arguments:

      :positioner_settling_time: settling time after positioners reach
                                 destination (default = 0)
      :counter_settling_time:    settling time after counters finish counting
                                 (default = 0)

  EXAMPLES::

    > epics_ascan ioc1:motor1 ioc1:motor1.RBV 3.2 3.6 20 0.5
        # scan the EPICS positioner "ioc1:motor1" from 3.2 to 3.6 in 20 steps
        # of 0.5 seconds and read back the position from "ioc1:motor1.RBV"

    > epics_ascan ioc1:ao1 ioc1:ao1 1.2 1.4 20 0.5 1 2
        # scan the EPICS analog output value of from 1.2 to 1.4 in
        # 20 steps with a positioner settling time of 1 second, and read back
        # the output value from the same PV "ioc1:ao1" with a counter settling
        # time of 2 seconds.

  """

  local _str, _pos_sleep, _cnt_sleep

  if ($# == 6) {
    _pos_sleep = 0.0
    _cnt_sleep = 0.0
  } else if ($# == 7) {
    _pos_sleep = $7
    _cnt_sleep = 0.0
  } else if ($# == 8) {
    _pos_sleep = $7
    _cnt_sleep = $8
  } else {
    _str = ""
    _str = _str "Usage:\n"
    _str = _str "  epics_ascan <drive_PV> <read_PV> <start> <finish> "
    _str = _str "<intervals> <time> ...\n"
    _str = _str "  [<positioner_settling_time> [<counter_settling_time>]]"
    eprint _str
    exit
  }

  _m[0] = "$1"
  EPICS_SCAN_READ_PVS[0] = "$2"
  _s[0] = $3; _f[0] = $4
  _n1 = int($5); _ctime = $6
  _nm = 1
  eval(sprintf("_epics_ascan %f %f", _pos_sleep, _cnt_sleep))

}'


#------------------------------------------------------------------------------
def epics_dscan '{
  """
  Relative scan of an EPICS positioner.

  USAGE::

    > epics_dscan <drive_PV> <read_PV> <start> <finish> <intervals> <time>
        [<positioner_settling_time> [<counter_settling_time>]]

  INPUTS:

    Required arguments:

      :drive_PV:   Name of the PV channel to drive the positioner
      :read_PV:    Name of the PV channel to read the positioner value
      :start:      Start position for the scan
      :finish:     End position for the scan
      :intervals:  Number of steps (points = steps+1)
      :time:       Counting time [s]

    Optional arguments:

      :positioner_settling_time: Settling time after positioners report
                                 reaching their destination (default = 0)
      :counter_settling_time:    Settling time after counters report to have
                                 finished counting (default = 0)

  EXAMPLES::

    > epics_dscan ioc1:motor1 ioc1:motor1.RBV -0.1 0.1 20 0.5
         # relative scan of the EPICS positioner "ioc1:motor1" from -0.1 to 0.1
         # in 20 steps of 0.5 seconds, reading back the position from
         # "ioc1:motor1.RBV"

     > epics_dscan ioc1:ao1 ioc1:ao1 1.2 1.4 20 0.5 1 2
         # scan the EPICS analog output value of "ioc1:ao1" from 1.2 to 1.4 in
         # 20 steps with a positioner settling time of 1 second, and read back
         # the output value from the same PV "ioc1:ao1" with a counter settling
         # time of 2 seconds.

  """

  local _str, _pos_sleep, _cnt_sleep, _curr_val

  if ($# == 6) {
    _pos_sleep = 0.0
    _cnt_sleep = 0.0
  } else if ($# == 7) {
    _pos_sleep = $7
    _cnt_sleep = 0.0
  } else if ($# == 8) {
    _pos_sleep = $7
    _cnt_sleep = $8
  } else {
    _str = ""
    _str = _str "Usage:\n"
    _str = _str "  epics_dscan <drive_PV> <read_PV> <start> <finish> "
    _str = _str "<intervals> <time> ...\n"
    _str = _str "  [<positioner_settling_time> [<counter_settling_time>]]"
    eprint _str
    exit
  }

  _m[0] = "$1"
  EPICS_SCAN_READ_PVS[0] = "$2"
  EPICS_SCAN_START_POS[0] = epics_get(_m[0])
  _s[0] = EPICS_SCAN_START_POS[0] + $3
  _f[0] = EPICS_SCAN_START_POS[0] + $4
  _n1 = int($5)
  _ctime = $6
  _nm = 1

  #: Add _epics_dscan_cleanup to cleanup_once
  cdef("cleanup_once", "\n{_epics_dscan_cleanup}; ", "epics_dscan_cleanup_key")

  # perform the actual scan
  eval(sprintf("_epics_ascan %f %f", _pos_sleep, _cnt_sleep))

  #: Remove _epics_dscan_cleanup from cleanup_once
  cdef("cleanup_once", "", "epics_dscan_cleanup_key", "delete")

  # move positioners back to original positions
  _epics_dscan_cleanup

}'


#------------------------------------------------------------------------------
def epics_d2scan '{
  """
  Relative scan of two EPICS positioners.

  USAGE::

    > epics_d2scan <drive_PV1> <read_PV1> <start1> <finish1>
                   <drive_PV2> <read_PV2> <start2> <finish2>
                   <intervals> <time>
                   [<positioner_settling_time> [<counter_settling_time>]]

  INPUTS:

    Required arguments:

      :drive_PV1:  Name of the first PV channel to drive the positioner
      :read_PV1:   Name of the first PV channel to read the positioner value
      :start1:     Start position for the first positioner
      :finish1:    End position for the first positioner
      :drive_PV2:  Name of the second PV channel to drive the positioner
      :read_PV2:   Name of the second PV channel to read the positioner value
      :start2:     Start position for the second positioner
      :finish2:    End position for the second positioner
      :intervals:  Number of steps (points = steps+1)
      :time:       Counting time [s]

    Optional arguments:

      :positioner_settling_time: settling time after positioners reach
                                 destination (default = 0)
      :counter_settling_time:    settling time after counters finish counting
                                 (default = 0)

  EXAMPLES::

    > epics_d2scan ioc1:motor1 ioc1:motor1.RBV -0.1 0.1
                   ioc1:motor2 ioc1:motor2.RBV -0.2 0.2 20 0.5
        # Relative scan of the EPICS positioners "ioc1:motor1" from
        # -0.1 to 0.1 and "ioc1:motor2" from -0.2 to 0.2
        # in 20 steps of 0.5 seconds, reading back the position from
        # "ioc1:motor1.RBV" and "ioc1:motor2.RBV"

  """

  local _str, _pos_sleep, _cnt_sleep, _curr_val

  if ($# == 10) {
    _pos_sleep = 0.0
    _cnt_sleep = 0.0
  } else if ($# == 11) {
    _pos_sleep = $11
    _cnt_sleep = 0.0
  } else if ($# == 12) {
    _pos_sleep = $11
    _cnt_sleep = $12
  } else {
    _str = ""
    _str = _str "Usage:\n"
    _str = _str "  epics_d2scan <drive_PV1> <read_PV1> <start1> <finish1> "
    _str = _str "<drive_PV2> <read_PV2> <start2> <finish2> "
    _str = _str "<intervals> <time> ...\n"
    _str = _str "  [<positioner_settling_time> [<counter_settling_time>]]"
    eprint _str
    exit
  }

  _m[0] = "$1"; _m[1] = "$5"
  EPICS_SCAN_READ_PVS[0] = "$2"; EPICS_SCAN_READ_PVS[1] = "$6"
  EPICS_SCAN_START_POS[0] = epics_get(_m[0])
  EPICS_SCAN_START_POS[1] = epics_get(_m[1])
  _s[0] = EPICS_SCAN_START_POS[0] + $3
  _s[1] = EPICS_SCAN_START_POS[1] + $7
  _f[0] = EPICS_SCAN_START_POS[0] + $4
  _f[1] = EPICS_SCAN_START_POS[1] + $8
  _n1 = int($9)
  _ctime = $10
  _nm = 2

  #: Add _epics_dscan_cleanup to cleanup_once
  cdef("cleanup_once", "\n{_epics_dscan_cleanup}; ", "epics_dscan_cleanup_key")

  # perform the actual scan
  eval(sprintf("_epics_ascan %f %f", _pos_sleep, _cnt_sleep))

  #: Remove _epics_dscan_cleanup from cleanup_once
  cdef("cleanup_once", "", "epics_dscan_cleanup_key", "delete")

  # move positioners back to original positions
  _epics_dscan_cleanup

}'


#------------------------------------------------------------------------------
def epics_mesh '{
  """
  Mesh scan of two EPICS positioners.

  USAGE::

    > epics_mesh <drive_PV1> <read_PV1> <start1> <finish1> <intervals1>
                 <drive_PV2> <read_PV2> <start2> <finish2> <intervals2>
                 <time>
                 [<positioner_settling_time> [<counter_settling_time>]]

  INPUTS:

    Required arguments:

      :drive_PV1:  Name of the first PV channel to drive the positioner
      :read_PV1:   Name of the first PV channel to read the positioner value
      :start1:     Start position for the first positioner
      :finish1:    End position for the first positioner
      :intervals1: Number of steps for positioner 1 (points = steps+1)
      :drive_PV2:  Name of the second PV channel to drive the positioner
      :read_PV2:   Name of the second PV channel to read the positioner value
      :start2:     Start position for the second positioner
      :finish2:    End position for the second positioner
      :intervals2: Number of steps for positioner 2 (points = steps+1)
      :time:       Counting time [s]

    Optional arguments:

      :positioner_settling_time: settling time after positioners reach
                                 destination (default = 0)
      :counter_settling_time:    settling time after counters finish counting
                                 (default = 0)

  EXAMPLES::

    > epics_mesh ioc1:motor1 ioc1:motor1.RBV -0.1 0.1 10
                 ioc1:motor2 ioc1:motor2.RBV -0.2 0.2 20 0.5
        # Mesh scan of the EPICS positioners "ioc1:motor1" from
        # -0.1 to 0.1 in 10 steps and "ioc1:motor2" from -0.2 to 0.2
        # in 20 steps of 0.5 seconds, reading back the position from
        # "ioc1:motor1.RBV" and "ioc1:motor2.RBV"

  """

  if ($# == 11) {
    _pos_sleep = 0.0
    _cnt_sleep = 0.0
  } else if ($# == 12) {
    _pos_sleep = $12
    _cnt_sleep = 0.0
  } else if ($# == 13) {
    _pos_sleep = $12
    _cnt_sleep = $13
  } else {
    _str = ""
    _str = _str "Usage:\n"
    _str = _str "  epics_mesh <drive_PV1> <read_PV1> <start1> <finish1> "
    _str = _str "<intervals1> <drive_PV2> <read_PV2> <start2> <finish2> "
    _str = _str "<intervals2> <time> ...\n"
    _str = _str "  [<positioner_settling_time> [<counter_settling_time>]]"
    eprint _str
    exit
  }

  _m[0] = "$1"; _s1 = $3; _f1 = $4; _n1 = int($5)
  _m[1] = "$6"; _s2 = $8; _f2 = $9; _n2 = int($10)
  _ctime = $11
  EPICS_SCAN_READ_PVS[0] = "$2"; EPICS_SCAN_READ_PVS[1] = "$7"

  if (_n1 <= 0 || _n2 <= 0) {
    eprint "Intervals <= 0"
    exit
  }

  # should do some limit checking here... not sure how to do this in the
  # general case for any epics record type  
  # _bad_lim = 0  
  # _chk_lim _m[0] _s1
  # _chk_lim _m[0] _f1
  # _chk_lim _m[1] _s2
  # _chk_lim _m[1] _f2
  # if (_bad_lim) exit

  HEADING = sprintf("epics_mesh  $1 $2 %g %g %g  $6 $7 %g %g %g  %g ",\
                     $3, $4, $5, $8, $9, $10, $11)

  _d1 = (_f1 - _s1) / _n1++; _d2 = (_f2 - _s2) / _n2++
  _nm=2
  _cols=2+_hkl_col
  X_L = "$1"; _sx = _s1; _fx = _f1
  Y_L = cnt_name(DET)
  _stype = 1|8|(2<<8)
  FPRNT=sprintf("%s  %s  %s  %s  ",_m[0], EPICS_SCAN_READ_PVS[0], _m[1], EPICS_SCAN_READ_PVS[1])
  PPRNT=sprintf("%8.8s %8.8s %8.8s %8.8s",_m[0], EPICS_SCAN_READ_PVS[0], _m[1], EPICS_SCAN_READ_PVS[1])
  VPRNT=sprintf("%9.9s %9.9s %9.9s %9.9s",_m[0], EPICS_SCAN_READ_PVS[0], _m[1], EPICS_SCAN_READ_PVS[1])
  FPRNT=sprintf("%s%s  ",FPRNT,_hkl_sym1)
  scan_head
  PFMT=sprintf("%%8.%df %%8.%df %%8.%df %%8.%df ",UP,UP,UP,UP)
  VFMT=sprintf("%%9.%df %%9.%df %%9.%df %%9.%df ",UP,UP,UP,UP)
  _g1 = _n1
  _g2 = 0
  local _drive_val1, _read_val1, _drive_val2, _read_val2
  def _scan_on \'
    for (; _g2 < _n2; _g2++){
      epics_put(_m[1], (_s2 + _g2 * _d2), EPICS_SCAN_CALLBACK_TIMEOUT)
      if (_g1 == _n1){
        _g1 = 0
      }
      for (; _g1 < _n1; _g1++, NPTS++) {
        epics_put(_m[0], (_s1 + _g1 * _d1), EPICS_SCAN_CALLBACK_TIMEOUT)
        sleep(_pos_sleep)
        _drive_val1 = epics_get(_m[0])
        _read_val1 = epics_get(EPICS_SCAN_READ_PVS[0])
        _drive_val2 = epics_get(_m[1])
        _read_val2 = epics_get(EPICS_SCAN_READ_PVS[1])
        FPRNT=sprintf("%.8g %.8g %.8g %.8g ",_drive_val1,_read_val1,_drive_val2,_read_val2)
        PPRNT=sprintf(PFMT,_drive_val1,_read_val1,_drive_val2,_read_val2)
        VPRNT=sprintf(VFMT,_drive_val1,_read_val1,_drive_val2,_read_val2)
        FPRNT=sprintf("%s%s ",FPRNT,_hkl_val)
        scan_loop
        sleep(_cnt_sleep)
        scan_data(_g1,_read_val1)
        scan_plot
      }
    }
    scan_tail
  \'
  _scan_on
}'


#==============================================================================
# Internal macro definitions (private and hidden)
#==============================================================================

#------------------------------------------------------------------------------
def _epics_ascan '
  """
  Low-level general epics scan macro which is called by the user-level
  macros :spec:def:`epics_ascan`, :spec:def:`epics_a2scan`, etc., and
  :spec:def:`epics_dscsan`, :spec:def:`epics_d2scan`, etc.

  DESCRIPTION:
    This general epics scan macro can deal with any number of positioners.
    Information is passed through the following global variables from the
    user-level macros (like :spec:def:`epics_ascan`, :spec:def:`epics_d2scan`,
    etc):

    :_m[]:   associate array of PV names for driving positioners
    :EPICS_SCAN_READ_PVS[]: associate array of PV names for reading positioners
    :_s[]:   associate array with all the positioner start values
    :_f[]:   associate array with all the positioner finish values
    :_n1:    number of scan intervals (steps)
    :_ctime: counting time
    :_nm:    total number of positioners to be scanned

  USAGE::

    > _epics_ascan [<positioner_settling_time> [<counter_settling_time>]]

  """

  local _pos_sleep, _cnt_sleep

  _pos_sleep = $1
  _cnt_sleep = $2

  # check if drive PV names are ok
  for (i=0;i<_nm;i++){
    _epics_scan_pv_test(_m[i])
  }

  # check if read PV names are ok
  for (i=0;i<_nm;i++){
    _epics_scan_pv_test(EPICS_SCAN_READ_PVS[i])
  }

  if (_n1 <= 0) {
	  eprint "Error in epics_ascan: Intervals <= 0"
	  exit
  } ;

  if(EPICS_SCAN_DEBUG){
      p "Drive PV names:"
      p _m
      p "Read PV names:"
      p EPICS_SCAN_READ_PVS
      p "Positioner settling time: " _pos_sleep
      p "Counter settling time: " _cnt_sleep
  }

  # should do some limit checking here... not sure how to do this in the
  # general case for any epics record type
  #{
  #  local i
  #	 for (i=0;i<_nm;i++) {
  #	  _bad_lim = 0
  #	  _chk_lim _m[i] _s[i]
  #	  _chk_lim _m[i] _f[i]
  #	  if (_bad_lim) exit;
  #	}
  #}

  # prepare the scan header for the spec file
  HEADING=_nm>1? sprintf("epics_a%dscan ", _nm):"epics_ascan "
  {
    local i
	for (i=0;i<_nm;i++) {
	  HEADING=sprintf("%s%s",HEADING,sprintf(" %s %g %g ",\
	    _m[i],_s[i],_f[i]))
	  _d[i] = (_f[i] - _s[i]) / _n1
	}
  }
  HEADING=sprintf("%s %g %g",HEADING,_n1,_ctime)
    _n1++
	_cols=(_nm*2)+_hkl_col
	X_L = EPICS_SCAN_READ_PVS[0]
	Y_L = cnt_name(DET)
	_sx = _s[0]; _fx = _f[0]
	_stype = 1|(_nm<<8)
	FPRNT=PPRNT=VPRNT=""
	{
	 local i
	 for (i=0;i<_nm;i++) {
	     # Note: there need to be TWO spaces between header columns in the
	     #       SPEC datafile!
	     FPRNT=sprintf("%s%s  %s  ",FPRNT, _m[i], EPICS_SCAN_READ_PVS[i])
	     PPRNT=sprintf("%s%s %s ",PPRNT, _m[i], EPICS_SCAN_READ_PVS[i])
	     VPRNT=sprintf("%s%s %s ",VPRNT, _m[i], EPICS_SCAN_READ_PVS[i])
	 }
	}
	FPRNT=sprintf("%s%s  ",FPRNT,_hkl_sym1)
	scan_head
	PFMT=sprintf("%%s%%8.%df %%8.%df ", UP, UP)
	VFMT=sprintf("%%s%%9.%df %%8.%df ", UP, UP)
	def _scan_on \'
	 for (; NPTS < _n1; NPTS++) {
		local i
		for (i=0;i<_nm;i++){
			epics_put(_m[i], _s[i]+(NPTS*_d[i]), EPICS_SCAN_CALLBACK_TIMEOUT)
		}
		sleep(_pos_sleep)
		FPRNT=PPRNT=VPRNT=""
		for (i=0;i<_nm;i++) {
		     local _drive_val, _read_val
		     _drive_val = epics_get(_m[i])
		     _read_val = epics_get(EPICS_SCAN_READ_PVS[i])
		     FPRNT=sprintf("%s%.8g %.8g ",FPRNT, _drive_val, _read_val)
		     PPRNT=sprintf(PFMT,PPRNT, _drive_val, _read_val)
		     VPRNT=sprintf(VFMT,VPRNT, _drive_val, _read_val)
		}
		FPRNT=sprintf("%s%s ",FPRNT,_hkl_val)
		scan_loop
		sleep(_cnt_sleep)
		scan_data(NPTS,epics_get(EPICS_SCAN_READ_PVS[0]))
		scan_plot
	 }
	 scan_tail
	\'
	_scan_on
'

#------------------------------------------------------------------------------
def _epics_scan_pv_test(pv_name) '{
  """
  Test if a PV name is valid. Continue quietly if yes, print error message
  and exit if not.

  USAGE::

    > _epics_scan_pv_test(<PV_name>)

  ARGUMENTS:
    :PV_name: The EPICS PV to be tested.

  """

  if(epics_par(pv_name,"type") == ""){
    local _str
    _str = sprintf("The requested EPICS channel %s does not seem to exist\n.",\
             pv_name)
    eprint _str
    exit
  }
}'


#------------------------------------------------------------------------------
def _epics_dscan_cleanup '{
  """
  Move all EPICS positioners back to their start positions before the scan.

  USAGE::

    > _epics_dscan_cleanup

  """

  for (i=0;i<_nm;i++) {
    printf("Returning %s to %g\n", _m[i], EPICS_SCAN_START_POS[i])
    epics_put(_m[i], EPICS_SCAN_START_POS[i], EPICS_SCAN_CALLBACK_TIMEOUT)
  }
  printf("\n")
}'


#==============================================================================
# End of $Id: epics_scan.mac 904 2014-03-10 20:43:55Z jemian $
#==============================================================================
