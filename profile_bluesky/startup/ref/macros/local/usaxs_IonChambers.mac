#
# usaxscontrol:/data/spec/macros/usaxs/usaxs_IonChambers.mac
#
# this file contains auxiliary usaxs commands....
#
########### SVN repository information ###################
# $Date: 2017-09-08 14:56:54 -0500 (Fri, 08 Sep 2017) $
# $Author: ilavsky $
# $Revision: 1433 $
# $HeadURL: https://subversion.xray.aps.anl.gov/spec/beamlines/USAXS/trunk/macros/local/usaxs_IonChambers.mac $
# $Id: usaxs_IonChambers.mac 1433 2017-09-08 19:56:54Z ilavsky $
########### SVN repository information ###################
#
#  USAXS-specific macros 
#  maintained by Jan Ilavsky
#  edit:  2012-Apr-5, JIL, first relase, moved controls for ion chmabers to new file
#         2012-June-23, JIL, modified for I0 and I00 sequence programs
#         2013-2-9, JIL, removed openTiFilterShutter from autranging. Do manually.
#         2013-06-16, JIL, modified to avoid hanging if sequence programs fail to update on time.  
#         2016-01-18, JIL:    modified for TR_diode amplifier

#-------------------------------------------------------------------------------


def autorange_I0I00amps'{
   # autoranges the I0/I00 to find proper range for current beam & slit conditions
  autorange_UPDI0I00

#   local old_ScalerDelay , __itmp
#   local shall_wait, __HowLongWaiting
#   old_ScalerDelay = epics_get("9idcLAX:vsc:c0.DLY")
#   epics_put("9idcLAX:vsc:c0.DLY",0.02)
#   #openTiFilterShutter
#   set_I0_gain 5
#   set_I00_gain 5
#   set_TRD_gain 4
#   sleep(0.02)
#   modeAutoRange_I0
#   modeAutoRange_I00
#   modeAutoRange_TRD
#   __HowLongWaiting=0
#   modeAutoRange_I0
#   modeAutoRange_I00
#   modeAutoRange_TRD
#   sleep(0.06)
#   for (__itmp=0; __itmp < 6; __itmp++) {
#    count 0.08 
#    __waitForSequencePrograms2
#    sleep(0.04)
#   }
#    #try to catch failed autoranging
#    count 0.08
#    local __CtsPerSecI0
#    local __CtsPerSecTRD
#    __CtsPerSecI0 = epics_get("9idcLAX:vsc:c0_cts1.B")
#    __CtsPerSecTRD = epics_get("9idcLAX:vsc:c0_cts2.A")

#    if ( __CtsPerSecI0 > 990000 && __CtsPerSecTRD>990000 && && epics_get("9idcUSX:pd02:seq01:lurange", "short")>0 ){
#      comment "AutorangeI0I00 failed, trying again"
#      for (__itmp=0; __itmp < 6; __itmp++) {
#       count 0.08
#       __waitForSequencePrograms
#        sleep(0.04)
#      }     
#    }     
#   modeManualRange_TRD
#   modeManualRange_I00
#   modeManualRange_I0
#   epics_put("9idcLAX:vsc:c0.DLY",old_ScalerDelay)
#   sleep(0.04)
}'

def __waitForSequencePrograms2'{
    local shall_wait
    shall_wait = Is_TRD_Updating || Is_I0_Updating || Is_I00_Updating
       while(shall_wait){ 
          sleep(0.05)   # while still updating, sleep for 50ms
          shall_wait = Is_TRD_Updating || Is_I0_Updating || Is_I00_Updating
       }  
}'
###################################################################################
###  measure USAXS all detectors dark currents
###
def measure_USAXS_DETS_dark_currents '{
  local range i retry str shutterOpened
  local oldCalcCtrl  oldCountTime
  local oldModeI0 oldAutoModeI0 oldRangeI0  
  local oldModeI00 oldAutoModeI00 oldRangeI00
  local oldModeTRD oldAutoModeTRD oldRangeTRD
  local sumI0 sumI0Sqr darkI0 esdI0
  local sumI00 sumI00Sqr darkI00 esdI00
  local sumTRD sumTRDSqr darkTRD esdTRD
  local numReadings shall_wait
  
    # remember which photodiode mode (manual, auto, auto+bkg)
    # put the scaler calculation in cts/sec mode
    # count for 0.5 second

  oldModeI0      = epics_get(sprintf("9idcUSX:%s:mode",I0string))
  oldRangeI0     = epics_get(sprintf("9idcUSX:%s:reqrange",I0string))
  oldModeI00     = epics_get(sprintf("9idcUSX:%s:mode",I00string))
  oldRangeI00    = epics_get(sprintf("9idcUSX:%s:reqrange",I00string))
  oldModeTRD     = epics_get(sprintf("9idcUSX:%s:mode",TRDstring))
  oldRangeTRD    = epics_get(sprintf("9idcUSX:%s:reqrange",TRDstring))
  oldCalcCtrl    = epics_get(sprintf("%s_calc_ctrl.VAL",_SCALER_PV))
  oldAutoMode    = epics_get(sprintf("%s.CONT",_SCALER_PV))
  oldScalerDelay = epics_get(sprintf("%s.DLY",_SCALER_PV))
  oldCountTime   = epics_get(sprintf("%s.TP",_SCALER_PV))
  epics_put(sprintf("9idcUSX:%s:mode",I0string), 0)
  epics_put(sprintf("9idcUSX:%s:mode",I00string), 0)
  epics_put(sprintf("%s_calc_ctrl",_SCALER_PV), 1)
  epics_put(sprintf("%s.CONT",_SCALER_PV), 0)
  epics_put(sprintf("%s.DLY",_SCALER_PV), 0)
  epics_put(sprintf("%s.TP",_SCALER_PV), 0.3)
  sleep(0.1)     #get modes settled... 
    # measure the dark currents on each range
    # get average and std dev of numReadings readings
  chk_beam_off
  closeTiFilterShutter
  sleep(0.1)
  numReadings = 5
  for (range=4; range >= 0; range--) {
   epics_put(sprintf("9idcUSX:%s:reqrange.VAL",I0string), range)
   epics_put(sprintf("9idcUSX:%s:reqrange.VAL",I00string), range)
   epics_put(sprintf("9idcUSX:%s:reqrange.VAL",TRDstring), range)
   sleep(0.2)   # this is to enable all ranges "stabilize" a bit. Really needed for highest gain only, but should not hurt... 
   count 0.05
   for (retry = 0; retry < 5; retry++) {
      sumFemto = 0;     sumFemtoSqr = 0
      sumI0 = 0;      sumI0Sqr = 0
      sumI00 = 0;     sumI00Sqr = 0
      sumTRD = 0;     sumTRDSqr = 0
      shutterOpened = 0;
      for (i=0; i < numReadings; i++) {
        count 0.2
        darkI0 = S[I0] / S[seconds]
        sumI0 += darkI0
        sumI0Sqr += darkI0*darkI0
        darkI00 = S[I00] / S[seconds]
        sumI00 += darkI00
        sumI00Sqr += darkI00*darkI00
        darkTRD = S[trd] / S[seconds]
        sumTRD += darkTRD
        sumTRDSqr += darkTRD*darkTRD
      }
      if (shutterOpened == 0) retry=5
    }
       # average the values
    darkI0 = sumI0 / numReadings
    esdI0  = sumI0Sqr - sumI0*sumI0/numReadings
    esdI0  = (esdI0 > 0) ? sqrt(esdI0 / (numReadings-1)) : 0
    darkI00 = sumI00 / numReadings
    esdI00  = sumI00Sqr - sumI00*sumI00/numReadings
    esdI00  = (esdI00 > 0) ? sqrt(esdI00 / (numReadings-1)) : 0
    darkTRD = sumTRD / numReadings
    esdTRD  = sumTRDSqr - sumTRD*sumTRD/numReadings
    esdTRD  = (esdTRD > 0) ? sqrt(esdTRD / (numReadings-1)) : 0
 
       # report the values
    str=sprintf("USAXS I0 dark current range %d = %g +/- %g c/s", range+1, darkI0, esdI0)
    comment "%s" str
    str=sprintf("USAXS I00 dark current range %d = %g +/- %g c/s", range+1, darkI00, esdI00)
    comment "%s" str
    str=sprintf("USAXS TRD dark current range %d = %g +/- %g c/s", range+1, darkTRD, esdTRD)
    comment "%s" str
    str=sprintf("%s%s%s%d", "9idcUSX:",I0string,":bkg", range)
    epics_put(str, darkI0)
    str=sprintf("%s%s%s%d", "9idcUSX:",I0string,":bkgErr", range)
    epics_put(str, esdI0)
    str=sprintf("%s%s%s%d", "9idcUSX:",I00string,":bkg", range)
    epics_put(str, darkI00)
    str=sprintf("%s%s%s%d", "9idcUSX:",I00string,":bkgErr", range)
    epics_put(str, esdI00)
    str=sprintf("%s%s%s%d", "9idcUSX:",TRDstring,":bkg", range)
    epics_put(str, darkTRD)
    str=sprintf("%s%s%s%d", "9idcUSX:",TRDstring,":bkgErr", range)
    epics_put(str, esdTRD)
  }
    # restore some settings
  epics_put(sprintf("9idcUSX:%s:mode",I0string),          oldModeI0)
  epics_put(sprintf("9idcUSX:%s:reqrange",I0string),      oldRangeI0)
  epics_put(sprintf("9idcUSX:%s:mode",I00string),         oldModeI00)
  epics_put(sprintf("9idcUSX:%s:reqrange",I00string),     oldRangeI00)
  epics_put(sprintf("9idcUSX:%s:mode",TRDstring),         oldModeTRD)
  epics_put(sprintf("9idcUSX:%s:reqrange",TRDstring),     oldRangeTRD)
  epics_put(sprintf("%s_calc_ctrl",_SCALER_PV),   oldCalcCtrl)
  epics_put(sprintf("%s.CONT",_SCALER_PV),        oldAutoMode)
  epics_put(sprintf("%s.TP",_SCALER_PV),          oldCountTime)
  epics_put(sprintf("%s.DLY",_SCALER_PV),         oldScalerDelay)
  chk_beam_on
}'



def modeAutoRange_TRD'{
     # puts TRD to autorange mode
     # sleep(0.1)
	epics_put("9idcUSX:pd05:seq01:mode","automatic")
}'

def modeAutoBRange_TRD'{
     # puts TRD to autorange mode
     # sleep(0.1)
	epics_put("9idcUSX:pd05:seq01:mode","auto+background")
}'

def modeManualRange_TRD'{
     # puts TRD to manual mode mode
     # sleep(0.1)
	epics_put("9idcUSX:pd05:seq01:mode","manual")
}'


def modeAutoRange_I0'{
     # puts I0 to autorange mode
     # sleep(0.1)
	epics_put("9idcUSX:pd02:seq01:mode","automatic")
}'

def modeAutoBRange_I0'{
     # puts I0 to autorange mode
     # sleep(0.1)
	epics_put("9idcUSX:pd02:seq01:mode","auto+background")
}'

def modeManualRange_I0'{
     # puts I0 to manual mode mode
     # sleep(0.1)
	epics_put("9idcUSX:pd02:seq01:mode","manual")
}'

def modeAutoRange_I00'{
     # puts I00 to autorange mode
     # sleep(0.1)
	epics_put("9idcUSX:pd03:seq01:mode","automatic")
}'

def modeAutoBRange_I00'{
     # puts I00 to autorange mode
     # sleep(0.1)
	epics_put("9idcUSX:pd03:seq01:mode","auto+background")
}'

def modeManualRange_I00'{
     # puts I00 to manual mode mode
     # sleep(0.1)
	epics_put("9idcUSX:pd03:seq01:mode","manual")

}'

def get_TRDMode 'epics_get("9idcUSX:pd05:seq01:mode","short")'

def Is_TRD_Updating '(get_TRDMode == 1) ? epics_get("9idcUSX:pd05:seq01:updating","short") : 0'

def get_I0Mode 'epics_get("9idcUSX:pd02:seq01:mode","short")'

def Is_I0_Updating '(get_I0Mode == 1) ? epics_get("9idcUSX:pd02:seq01:updating","short") : 0'

def get_I00Mode 'epics_get("9idcUSX:pd03:seq01:mode","short")'

def Is_I00_Updating '(get_I00Mode == 1) ? epics_get("9idcUSX:pd03:seq01:updating","short") : 0'


def set_TRD_gain'{
   # value can be 5, 6, 7, 8, or 9 and this means gain 1e5, 1e6, 1e7, 1e8, and 1e9
   # using only low noise gains as those are the only which actually work
  local __target 
  if( $# != 1) {
    printf ("usage: set_TRD_gain Value\n")
    exit;
  }
  __target = $1

  modeManualRange_TRD   #makes sense ONLY if in manual mode

  if( __target == 5) {
		epics_put("9idcUSX:fem05:seq01:gainidx","1e5 low noise")
  }
  if( __target == 6) {
		epics_put("9idcUSX:fem05:seq01:gainidx","1e6 low noise")
  }
  if( __target == 7) {
		epics_put("9idcUSX:fem05:seq01:gainidx","1e7 low noise")
  }
  if( __target == 8) {
		epics_put("9idcUSX:fem05:seq01:gainidx","1e8 low noise")
  }
  if( __target == 9) {
		epics_put("9idcUSX:fem05:seq01:gainidx","1e9 low noise")
  }
  if( __target == 10) {
		epics_put("9idcUSX:fem05:seq01:gainidx","1e10 high speed")
  }
}'


def set_I0_gain'{
   # value can be 5, 6, 7, 8, or 9 and this means gain 1e5, 1e6, 1e7, 1e8, and 1e9
   # using only low noise gains as those are the only which actually work
  local __target 
  if( $# != 1) {
    printf ("usage: set_I0_gain Value\n")
    exit;
  }
  __target = $1

  modeManualRange_I0   #makes sense ONLY if in manual mode

  if( __target == 5) {
		epics_put("9idcUSX:fem02:seq01:gainidx","1e5 low noise")
  }
  if( __target == 6) {
		epics_put("9idcUSX:fem02:seq01:gainidx","1e6 low noise")
  }
  if( __target == 7) {
		epics_put("9idcUSX:fem02:seq01:gainidx","1e7 low noise")
  }
  if( __target == 8) {
		epics_put("9idcUSX:fem02:seq01:gainidx","1e8 low noise")
  }
  if( __target == 9) {
		epics_put("9idcUSX:fem02:seq01:gainidx","1e9 low noise")
  }
  if( __target == 10) {
		epics_put("9idcUSX:fem02:seq01:gainidx","1e10 high speed")
  }
}'

def set_I00_gain'{
   # value can be 5, 6, 7, 8, or 9 and this means gain 1e5, 1e6, 1e7, 1e8, and 1e9
   # using only low noise gains as those are the only which actually work
  local __target 
  if( $# != 1) {
    printf ("usage: set_I0_gain Value\n")
    exit;
  }
  __target = $1
  
  modeManualRange_I00

  if( __target == 5) {
		epics_put("9idcUSX:fem03:seq01:gainidx","1e5 low noise")
  }
  if( __target == 6) {
		epics_put("9idcUSX:fem03:seq01:gainidx","1e6 low noise")
  }
  if( __target == 7) {
		epics_put("9idcUSX:fem03:seq01:gainidx","1e7 low noise")
  }
  if( __target == 8) {
		epics_put("9idcUSX:fem03:seq01:gainidx","1e8 low noise")
  }
  if( __target == 9) {
		epics_put("9idcUSX:fem03:seq01:gainidx","1e9 low noise")
  }
  if( __target == 10) {
		epics_put("9idcUSX:fem03:seq01:gainidx","1e10 high speed")
  }
}'


