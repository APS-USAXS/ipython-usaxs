#
#  usaxs_diode.mac 
#
#  USAXS-specific macros 
#  maintained by Jan Ilavsky

########### SVN repository information ###################
# $Date: 2017-09-08 15:16:31 -0500 (Fri, 08 Sep 2017) $
# $Author: ilavsky $
# $Revision: 1434 $
# $HeadURL: https://subversion.xray.aps.anl.gov/spec/beamlines/USAXS/trunk/macros/local/usaxs_diode.mac $
# $Id: usaxs_diode.mac 1434 2017-09-08 20:16:31Z ilavsky $
########### SVN repository information ###################
#
#   This file contains macros to control USAXS PD...
# 2002-06        - replaced all lax:upd2 with 32idbUSX:pd01:seq01 to move UPD to e-brick 
# 2007-09-10,PRJ:  replaced all "lax:" with "32idbLAX:"
# 2007-09-27       replaced all brq: with 32idbUSX: since the PVV names changed. JIL
# 2010-04-21,JIL - changed counting time to 0.3 seconds. let's see if that works 
# 2010-06-30,XJ  - changed 32idbUSX to 9idcUSX after moved to 15ID
# 2010-10-10,JIL - modified to use either DLPCA200 or DLPCA300
# 2012-4-27,JIL  - modified to use new PV with DPPCA300 to wait until sequence program
#                  is done
# 2012-6-26, JIL, - modified autoranging gains for amplifiers
# 2012-12 JIL, diodes chaning on fly... 
# 2013-2 JIL, removed from diode autorage openTiFiltershutter, should be done manually when needed
# 2013-04 JIL, modified to use last update I0 and I00 range when USAXS scanning
# 2013-06 JIL, modified to handle better if sequence programs hang
# 2014-03 JIL, modified to measure also I0 and I00 dark currents during measure_USAXS_PD_dark_currents and sped up 
#              by using is)updating instead of fixed 1s sleep time.
# 2017-09-07, JIL:    added autoranging better support
###################################################################################

def getUSAXSdiode '
    local shall_wait
       shall_wait = Is_UPD_Updating
       while(shall_wait) {
         sleep(0.02)   # while still updating, sleep for 20ms
	   shall_wait = Is_UPD_Updating
       }       
       DIODE_range=epics_get(sprintf("%s:lurange",UPD_PV), "short")+1;
       DIODE_counts=epics_get(sprintf("%s:lucounts",UPD_PV));
       DIODE_rate=epics_get(sprintf("%s:lurate",UPD_PV));
       DIODE_current=epics_get(sprintf("%s:lucurrent",UPD_PV));
 '

###################################################################################
#def autorange_UPDI0I00'{
#   # autoranges the UPD, I0, I00 amplifiers to find proper range for current beam & slit conditions
#   local old_ScalerDelay , __itmp    
#   local shall_wait, __HowLongWaiting
#   old_ScalerDelay = epics_get("9idcLAX:vsc:c0.DLY")
#   epics_put("9idcLAX:vsc:c0.DLY",0.02)
#   #openTiFilterShutter
#   set_I0_gain 5
#   set_I00_gain 5
#   set_UPD_gain 4
#   set_TRD_gain 4
#   sleep(0.02)
#   modeAutoRange_I0
#   modeAutoRange_I00
#   modeAutoRange_UPD
#   modeAutoRange_TRD
#   sleep(0.04)
#   for (__itmp=0; __itmp < 6; __itmp++) {
#     count 0.08
#     __waitForSequencePrograms
#     sleep(0.04)
#    }     
#    #try to catch failed autoranging
#    count 0.08
#    sleep(0.02)
#    local __CtsPerSecI0
#    local __CtsPerSecTRD
#    local __CtsPerSecUPD
#    __CtsPerSecI0 = epics_get("9idcLAX:vsc:c0_cts1.B")
#    __CtsPerSecTRD = epics_get("9idcLAX:vsc:c0_cts2.A")
#    __CtsPerSecUPD = epics_get("9idcLAX:vsc:c0_cts1.D")#

#    if ( __CtsPerSecI0 > 990000 || __CtsPerSecTRD>990000 || __CtsPerSecUPD>990000){
#       #### DIODE_range>1 && epics_get("9idcUSX:pd02:seq01:lurange", "short")>0 )
#      comment "AutorangeUPDI0I00 failed, trying again"
#      for (__itmp=0; __itmp < 5; __itmp++) {
#       count 0.08
#       __waitForSequencePrograms
#        sleep(0.04)
#      }     
#    }     
#    modeManualRange_I0
#    modeManualRange_I00
#    modeManualRange_UPD
#    modeManualRange_TRD
#    epics_put("9idcLAX:vsc:c0.DLY",old_ScalerDelay)
#    sleep(0.04)
#}'

def autorange_UPDI0I00'{
   # autoranges the UPD, I0, I00 amplifiers to find proper range for current beam & slit conditions

   local old_ScalerDelay , __itmp    
   local oldUPD, oldI0, oldTRD, oldI00
   local UPDchanged, I0changed,I00changed, TRDchanged
   local UPDtopped, I0topped,I00topped, TRDtopped
   local __CtsPerSecI0
   local __CtsPerSecI00
   local __CtsPerSecTRD
   local __CtsPerSecUPD

   old_ScalerDelay = epics_get("9idcLAX:vsc:c0.DLY")
   epics_put("9idcLAX:vsc:c0.DLY",0.02)
   epics_put("9idcLAX:vsc:c0.CONT", 0) #one shot mode
   # use of one shot mode is necessary here. It is faster. 
   #epics_put("9idcLAX:vsc:c0.CONT", 1) #auto shot mode
        ## set to last useful values...
   set_I0_gain AutorangeOldI0Range
   set_I00_gain AutorangeOldI00Range
   set_UPD_gain AutorangeOldUPDRange
   set_TRD_gain AutorangeOldTRDRange
   ## or set to defaults
   #set_I0_gain 5
   #set_I00_gain 5
   #set_UPD_gain 4
   #set_TRD_gain 4
          ##make sure the amplfiers had time to settle down. 
   sleep(0.05)
   modeAutoRange_I0
   modeAutoRange_I00
   modeAutoRange_UPD
   modeAutoRange_TRD
    
   UPDchanged=1
   I0changed=1
   I00changed=1
   TRDchanged=1
   oldUPD=DIODERange
   oldI0=I0Range
   oldI00=I00Range
   oldTRD=TRDRange
   __itmp = 0
          #now find the right gain. Use loop until we do not change AND we are not topped up. 
   while((UPDchanged || I0changed || I00changed || TRDchanged || UPDtopped || I0topped || I00topped || TRDtopped)&&(__itmp<9)){
     sleep(0.08)           ## gain settling time for the device is <150ms. This is pushing it! 
     count 0.08
     sleep(0.01)           ## we were getting ahead of sequence programs here. Not sure why... This is necessary
     __waitForSequencePrograms
     __CtsPerSecI0  = epics_get("9idcLAX:vsc:c0_cts1.B")
     __CtsPerSecI00 = epics_get("9idcLAX:vsc:c0_cts1.C")
     __CtsPerSecTRD = epics_get("9idcLAX:vsc:c0_cts2.A")
     __CtsPerSecUPD = epics_get("9idcLAX:vsc:c0_cts1.D")
     __itmp++
     #comment "UDP gain %g" DIODERange 		## uncomment for debugging purposes. 
     #comment "Old UDP gain %g" oldUPD  	## uncomment for debugging purposes. 
           # check if we need to iterate again. 
     if(DIODERange!=oldUPD)   {UPDchanged=1}else{UPDchanged=0}
     if(I0Range!=oldI0)       {I0changed=1} else{I0changed=0}
     if(I00Range!=oldI00)     {I00changed=1}else{I00changed=0}
     if(TRDRange!=oldTRD)     {TRDchanged=1}else{TRDchanged=0}
          # are we topped up on any detector?
     if(__CtsPerSecI0  > 950000){I0topped=1} else{I0topped=0}
     if(__CtsPerSecI00 > 950000){I00topped=1}else{I00topped=0}
     if(__CtsPerSecTRD > 950000){TRDtopped=1}else{TRDtopped=0}
     if(__CtsPerSecUPD > 950000){UPDtopped=1}else{UPDtopped=0}
          # store values for next cycle, if needed. 
     oldUPD =  DIODERange
     oldI0  =  I0Range
     oldI00 =  I00Range
     oldTRD =  TRDRange
          # debugging message, uncomment if needed. 
     #tempComment = sprintf("Values %g, %g, %g, %g, %g, %g, %g, %g ", UPDchanged, I0changed, I00changed, TRDchanged, UPDtopped, I0topped, I00topped, TRDtopped)
     #comment "%s" tempComment  
   }
          # this is warning, that the code fails to find proper gain on multiple iterations. Something failed badly... 
   if(__itmp>7){comment "FAILED TO FIND CORRECT GAIN IN 9 ITERATIONS"}
          # debugging message, uncomment if needed. 
   #tempComment = sprintf("Autoranging finished after %g iterations", __itmp)
   #comment "%s" tempComment  
          # Set to correct conditions expected after this is run... .  
    modeManualRange_I0
    modeManualRange_I00
    modeManualRange_UPD
    modeManualRange_TRD
          # This is used next time we call Autorange to set prior known conditions and save therefor time. 
    AutorangeOldUPDRange = DIODERange
    AutorangeOldI0Range  = I0Range
    AutorangeOldI00Range = I00Range
    AutorangeOldTRDRange = TRDRange
          # Return delay back. 
    epics_put("9idcLAX:vsc:c0.DLY",old_ScalerDelay)
}'


###################################################################################
def modeAutoRange_TRD'{
     # puts UPD to autorange mode
     # sleep(0.1)
	epics_put(sprintf("%s:mode",TRD_PV),"automatic")
}'

def modeAutoBRange_TRD'{
     # puts UPD to autorange mode
     # sleep(0.1)
	epics_put(sprintf("%s:mode",TRD_PV),"auto+background")
}'

def modeManualRange_TRD'{
     # puts UPD to manual mode mode
     # sleep(0.1)
	epics_put(sprintf("%s:mode",TRD_PV),"manual")
}'

def modeAutoRange_UPD'{
     # puts UPD to autorange mode
     # sleep(0.1)
	epics_put(sprintf("%s:mode",UPD_PV),"automatic")
}'

def modeAutoBRange_UPD'{
     # puts UPD to autorange mode
     # sleep(0.1)
	epics_put(sprintf("%s:mode",UPD_PV),"auto+background")
}'

def modeManualRange_UPD'{
     # puts UPD to manual mode mode
     # sleep(0.1)
	epics_put(sprintf("%s:mode",UPD_PV),"manual")
}'

def get_UPDMode 'epics_get(sprintf("%s:mode",UPD_PV),"short")'

def Is_UPD_Updating '(get_UPDMode == 1) ? epics_get(sprintf("%s:updating",UPD_PV),"short") : 0'

###################################################################################
def set_UPD_gain'{
   # value can be 4, 6, 8, 10, or 12 and this means gain 1e4, 1e6, 1e8, 1e10, and 1e12
   # using only low noise gains as those are the only which actually work
  local __target 
  if( $# != 1) {
    printf ("usage: set_I0_gain Value\n")
    exit;
  }
  __target = $1

  modeManualRange_UPD   #makes sense ONLY if in manual mode

  if( __target == 4) {
        epics_put(sprintf("9idcUSX:%s:reqrange.VAL",PDstring), 0)
  }
  if( __target == 6) {
        epics_put(sprintf("9idcUSX:%s:reqrange.VAL",PDstring), 1)
  }
  if( __target == 8) {
         epics_put(sprintf("9idcUSX:%s:reqrange.VAL",PDstring), 2)       
  }
  if( __target == 10) {
         epics_put(sprintf("9idcUSX:%s:reqrange.VAL",PDstring), 3)
 }
  if( __target == 12) {
         epics_put(sprintf("9idcUSX:%s:reqrange.VAL",PDstring), 4)
 }
}'

###################################################################################
###  measure USAXS PD dark currents
###
def measure_USAXS_PD_dark_currents '{
  local range i retry str shutterOpened
  local oldCalcCtrl  oldCountTime
  local oldModeFemto oldAutoModeFemto oldRangeFemto
  local sumFemtoL sumFemtoSqrL darkFemtoL esdFemtoL
  local numReadings shall_wait
  global __OverrideUPD5Background
  
    # remember which photodiode mode (manual, auto, auto+bkg)
    # put the scaler calculation in cts/sec mode
    # count for 0.5 second
  
  oldModeFemto   = epics_get(sprintf("9idcUSX:%s:mode",PDstring))
  oldRangeFemto  = epics_get(sprintf("9idcUSX:%s:reqrange",PDstring))
  oldCalcCtrl    = epics_get(sprintf("%s_calc_ctrl.VAL",_SCALER_PV))
  oldAutoMode    = epics_get(sprintf("%s.CONT",_SCALER_PV))
  oldScalerDelay = epics_get(sprintf("%s.DLY",_SCALER_PV))
  oldCountTime   = epics_get(sprintf("%s.TP",_SCALER_PV))
  epics_put(sprintf("9idcUSX:%s:mode",PDstring), 0)
  epics_put(sprintf("9idcUSX:%s:reqrange.VAL",PDstring), 4)
  epics_put(sprintf("%s_calc_ctrl",_SCALER_PV), 1)
  epics_put(sprintf("%s.CONT",_SCALER_PV), 0)
  epics_put(sprintf("%s.DLY",_SCALER_PV), 0)
  epics_put(sprintf("%s.TP",_SCALER_PV), 0.2)
  sleep(0.1)     #get modes settled... 
    # measure the dark currents on each range
    # get average and std dev of numReadings readings
  chk_beam_off
  closeTiFilterShutter
  sleep(0.1)
  numReadings = 5
  for (range=4; range >= 0; range--) {
      # set the photodiode range
   epics_put(sprintf("9idcUSX:%s:reqrange.VAL",PDstring), range)
   if(range>=3){sleep(1)}   
   count 0.05
   sleep(0.1)   # this is to enable all ranges "stabilize" a bit. Really needed for highest gain only, but should not hurt... 
   for (retry = 0; retry < 5; retry++) {
      sumFemtoL = 0;     sumFemtoSqrL = 0
      darkFemtoL = 0
      shutterOpened = 0;
      for (i=0; i < numReadings; i++) {
        count 0.2
        darkFemtoL = S[upd2] / S[seconds]
        sumFemtoL += darkFemtoL
        sumFemtoSqrL += darkFemtoL*darkFemtoL
      }
      if (shutterOpened == 0) retry=5
    }
        # average the values
    darkFemtoL = sumFemtoL / numReadings
    esdFemtoL  = sumFemtoSqrL - sumFemtoL*sumFemtoL/numReadings
    esdFemtoL  = (esdFemtoL > 0) ? sqrt(esdFemtoL / (numReadings-1)) : 0
        # override UPD5 background, if user wants
    if(range == 4){
        if(__OverrideUPD5Background == 0){} else{
           darkFemtoL = __OverrideUPD5Background
           esdFemtoL = 0
        }
     }
        # report the values
    str=sprintf("USAXS upd2 FemtoPD dark current range %d = %g +/- %g c/s", range+1, darkFemtoL, esdFemtoL)
    comment "%s" str
    str=sprintf("%s%s%s%d", "9idcUSX:",PDstring,":bkg", range)
    epics_put(str, darkFemtoL)
    str=sprintf("%s%s%s%d", "9idcUSX:",PDstring,":bkgErr", range)
    epics_put(str, esdFemtoL)
  }
    # restore some settings
  epics_put(sprintf("9idcUSX:%s:mode",PDstring),          oldModeFemto)
  epics_put(sprintf("9idcUSX:%s:reqrange",PDstring),      oldRangeFemto)
  epics_put(sprintf("%s_calc_ctrl",_SCALER_PV),   oldCalcCtrl)
  epics_put(sprintf("%s.CONT",_SCALER_PV),        oldAutoMode)
  epics_put(sprintf("%s.TP",_SCALER_PV),          oldCountTime)
  epics_put(sprintf("%s.DLY",_SCALER_PV),         oldScalerDelay)
  chk_beam_on
}'

####################  wait for sequence programs to finish updating 

def __waitForSequencePrograms'{
    local shall_wait
    shall_wait = Is_UPD_Updating || Is_I0_Updating || Is_I00_Updating
       while(shall_wait){ 
          sleep(0.05)   # while still updating, sleep for 50ms
          shall_wait = Is_UPD_Updating || Is_I0_Updating || Is_I00_Updating
       }  
}'
